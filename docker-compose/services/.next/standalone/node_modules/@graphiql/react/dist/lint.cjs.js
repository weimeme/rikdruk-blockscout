"use strict";var E=Object.defineProperty;var d=(e,i)=>E(e,"name",{value:i,configurable:!0});var g=require("./codemirror.cjs.js"),t=require("graphql"),w=require("./types.cjs.js"),p=require("./Range.cjs.js");require("./index.cjs.js");require("react");require("react-dom");const q=[t.LoneSchemaDefinitionRule,t.UniqueOperationTypesRule,t.UniqueTypeNamesRule,t.UniqueEnumValueNamesRule,t.UniqueFieldDefinitionNamesRule,t.UniqueDirectiveNamesRule,t.KnownTypeNamesRule,t.KnownDirectivesRule,t.UniqueDirectivesPerLocationRule,t.PossibleTypeExtensionsRule,t.UniqueArgumentNamesRule,t.UniqueInputFieldNamesRule];function N(e,i,a,u,r){const n=t.specifiedRules.filter(o=>!(o===t.NoUnusedFragmentsRule||o===t.ExecutableDefinitionsRule||u&&o===t.KnownFragmentNamesRule));return a&&Array.prototype.push.apply(n,a),r&&Array.prototype.push.apply(n,q),t.validate(e,i,n).filter(o=>{if(o.message.indexOf("Unknown directive")!==-1&&o.nodes){const l=o.nodes[0];if(l&&l.kind===t.Kind.DIRECTIVE){const c=l.name.value;if(c==="arguments"||c==="argumentDefinitions")return!1}}return!0})}d(N,"validateWithCustomRules");const f={Error:"Error",Warning:"Warning",Information:"Information",Hint:"Hint"},h={[f.Error]:1,[f.Warning]:2,[f.Information]:3,[f.Hint]:4},m=d((e,i)=>{if(!e)throw new Error(i)},"invariant");function D(e,i=null,a,u,r){var n,s;let o=null;r&&(typeof r=="string"?e+=`

`+r:e+=`

`+r.reduce((l,c)=>(l+=t.print(c)+`

`,l),""));try{o=t.parse(e)}catch(l){if(l instanceof t.GraphQLError){const c=L((s=(n=l.locations)===null||n===void 0?void 0:n[0])!==null&&s!==void 0?s:{line:0,column:0},e);return[{severity:h.Error,message:l.message,source:"GraphQL: Syntax",range:c}]}throw l}return C(o,i,a,u)}d(D,"getDiagnostics");function C(e,i=null,a,u){if(!i)return[];const r=v(N(i,e,a,u),s=>R(s,h.Error,"Validation")),n=v(t.validate(i,e,[t.NoDeprecatedCustomRule]),s=>R(s,h.Warning,"Deprecation"));return r.concat(n)}d(C,"validateQuery");function v(e,i){return Array.prototype.concat.apply([],e.map(i))}d(v,"mapCat");function R(e,i,a){if(!e.nodes)return[];const u=[];return e.nodes.forEach(r=>{const n=r.kind!=="Variable"&&"name"in r&&r.name!==void 0?r.name:"variable"in r&&r.variable!==void 0?r.variable:r;if(n){m(e.locations,"GraphQL validation error requires locations.");const s=e.locations[0],o=P(n),l=s.column+(o.end-o.start);u.push({source:`GraphQL: ${a}`,message:e.message,severity:i,range:new p.Range(new p.Position(s.line-1,s.column-1),new p.Position(s.line-1,l))})}}),u}d(R,"annotations");function L(e,i){const a=w.onlineParser(),u=a.startState(),r=i.split(`
`);m(r.length>=e.line,"Query text must have more lines than where the error happened");let n=null;for(let c=0;c<e.line;c++)for(n=new p.CharacterStream(r[c]);!n.eol()&&a.token(n,u)!=="invalidchar";);m(n,"Expected Parser stream to be available.");const s=e.line-1,o=n.getStartOfToken(),l=n.getCurrentPosition();return new p.Range(new p.Position(s,o),new p.Position(s,l))}d(L,"getRange");function P(e){const a=e.loc;return m(a,"Expected ASTNode to have a location."),a}d(P,"getLocation");const y=["error","warning","information","hint"],S={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};g.CodeMirror.registerHelper("lint","graphql",(e,i)=>{const a=i.schema;return D(e,a,i.validationRules,void 0,i.externalFragments).map(n=>({message:n.message,severity:n.severity?y[n.severity-1]:y[0],type:n.source?S[n.source]:void 0,from:g.CodeMirror.Pos(n.range.start.line,n.range.start.character),to:g.CodeMirror.Pos(n.range.end.line,n.range.end.character)}))});
