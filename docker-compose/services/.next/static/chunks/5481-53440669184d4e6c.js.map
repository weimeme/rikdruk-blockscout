{"version":3,"file":"static/chunks/5481-53440669184d4e6c.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@sentry/core/esm/version.js","webpack://_N_E/./node_modules/@sentry/core/esm/integrations/inboundfilters.js","webpack://_N_E/./node_modules/@sentry/core/esm/integrations/functiontostring.js","webpack://_N_E/./node_modules/@sentry/core/esm/integration.js","webpack://_N_E/./node_modules/@sentry/core/esm/sdk.js","webpack://_N_E/./node_modules/@sentry/utils/esm/stacktrace.js","webpack://_N_E/./node_modules/@sentry/utils/esm/error.js","webpack://_N_E/./node_modules/@sentry/utils/esm/dsn.js","webpack://_N_E/./node_modules/@sentry/utils/esm/memo.js","webpack://_N_E/./node_modules/@sentry/utils/esm/normalize.js","webpack://_N_E/./node_modules/@sentry/utils/esm/envelope.js","webpack://_N_E/./node_modules/@sentry/core/esm/api.js","webpack://_N_E/./node_modules/@sentry/core/esm/envelope.js","webpack://_N_E/./node_modules/@sentry/core/esm/baseclient.js","webpack://_N_E/./node_modules/@sentry/utils/esm/clientreport.js","webpack://_N_E/./node_modules/@sentry/browser/esm/eventbuilder.js","webpack://_N_E/./node_modules/@sentry/browser/esm/helpers.js","webpack://_N_E/./node_modules/@sentry/utils/esm/severity.js","webpack://_N_E/./node_modules/@sentry/utils/esm/url.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/breadcrumbs.js","webpack://_N_E/./node_modules/@sentry/browser/esm/client.js","webpack://_N_E/./node_modules/@sentry/browser/esm/stack-parsers.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/trycatch.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/globalhandlers.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/linkederrors.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/dedupe.js","webpack://_N_E/./node_modules/@sentry/browser/esm/integrations/httpcontext.js","webpack://_N_E/./node_modules/@sentry/utils/esm/promisebuffer.js","webpack://_N_E/./node_modules/@sentry/utils/esm/ratelimit.js","webpack://_N_E/./node_modules/@sentry/core/esm/transports/base.js","webpack://_N_E/./node_modules/@sentry/browser/esm/transports/utils.js","webpack://_N_E/./node_modules/@sentry/browser/esm/transports/fetch.js","webpack://_N_E/./node_modules/@sentry/browser/esm/transports/xhr.js","webpack://_N_E/./node_modules/@sentry/browser/esm/sdk.js","webpack://_N_E/./node_modules/@sentry/react/esm/sdk.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/hubextensions.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/span.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/transaction.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/idletransaction.js","webpack://_N_E/./node_modules/@sentry/utils/esm/tracing.js","webpack://_N_E/./node_modules/@sentry/utils/esm/baggage.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/types.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/backgroundtab.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/bindReporter.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/generateUniqueID.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getNavigationEntry.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getActivationStart.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/initMetric.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/observe.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/onHidden.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/getCLS.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/lib/getVisibilityWatcher.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/getFID.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/web-vitals/getLCP.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/metrics/utils.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/metrics/index.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/request.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/router.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/browser/browsertracing.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/index.js","webpack://_N_E/./node_modules/@sentry/tracing/esm/utils.js","webpack://_N_E/./node_modules/@sentry/utils/esm/buildPolyfills/_nullishCoalesce.js","webpack://_N_E/./node_modules/@sentry/utils/esm/buildPolyfills/_optionalChain.js","webpack://_N_E/./node_modules/@sentry/utils/esm/instrument.js","webpack://_N_E/./node_modules/@sentry/utils/esm/supports.js","webpack://_N_E/./node_modules/next/head.js","webpack://_N_E/<anon>"],"sourcesContent":["const SDK_VERSION = '7.24.0';\n\nexport { SDK_VERSION };\n//# sourceMappingURL=version.js.map\n","import { logger, getEventDescription, stringMatchesSomePattern } from '@sentry/utils';\n\n// \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\nconst DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n\n/** Options for the InboundFilters integration */\n\n/** Inbound filters configurable by the user */\nclass InboundFilters  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'InboundFilters';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = InboundFilters.id;}\n\n   constructor(  _options = {}) {;this._options = _options;InboundFilters.prototype.__init.call(this);}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    const eventProcess = (event) => {\n      const hub = getCurrentHub();\n      if (hub) {\n        const self = hub.getIntegration(InboundFilters);\n        if (self) {\n          const client = hub.getClient();\n          const clientOptions = client ? client.getOptions() : {};\n          const options = _mergeOptions(self._options, clientOptions);\n          return _shouldDropEvent(event, options) ? null : event;\n        }\n      }\n      return event;\n    };\n\n    eventProcess.id = this.name;\n    addGlobalEventProcessor(eventProcess);\n  }\n} InboundFilters.__initStatic();\n\n/** JSDoc */\nfunction _mergeOptions(\n  internalOptions = {},\n  clientOptions = {},\n) {\n  return {\n    allowUrls: [...(internalOptions.allowUrls || []), ...(clientOptions.allowUrls || [])],\n    denyUrls: [...(internalOptions.denyUrls || []), ...(clientOptions.denyUrls || [])],\n    ignoreErrors: [\n      ...(internalOptions.ignoreErrors || []),\n      ...(clientOptions.ignoreErrors || []),\n      ...DEFAULT_IGNORE_ERRORS,\n    ],\n    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true,\n  };\n}\n\n/** JSDoc */\nfunction _shouldDropEvent(event, options) {\n  if (options.ignoreInternal && _isSentryError(event)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(`Event dropped due to being internal Sentry Error.\\nEvent: ${getEventDescription(event)}`);\n    return true;\n  }\n  if (_isIgnoredError(event, options.ignoreErrors)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `Event dropped due to being matched by \\`ignoreErrors\\` option.\\nEvent: ${getEventDescription(event)}`,\n      );\n    return true;\n  }\n  if (_isDeniedUrl(event, options.denyUrls)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `Event dropped due to being matched by \\`denyUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  if (!_isAllowedUrl(event, options.allowUrls)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `Event dropped due to not being matched by \\`allowUrls\\` option.\\nEvent: ${getEventDescription(\n          event,\n        )}.\\nUrl: ${_getEventFilterUrl(event)}`,\n      );\n    return true;\n  }\n  return false;\n}\n\nfunction _isIgnoredError(event, ignoreErrors) {\n  if (!ignoreErrors || !ignoreErrors.length) {\n    return false;\n  }\n\n  return _getPossibleEventMessages(event).some(message => stringMatchesSomePattern(message, ignoreErrors));\n}\n\nfunction _isDeniedUrl(event, denyUrls) {\n  // TODO: Use Glob instead?\n  if (!denyUrls || !denyUrls.length) {\n    return false;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? false : stringMatchesSomePattern(url, denyUrls);\n}\n\nfunction _isAllowedUrl(event, allowUrls) {\n  // TODO: Use Glob instead?\n  if (!allowUrls || !allowUrls.length) {\n    return true;\n  }\n  const url = _getEventFilterUrl(event);\n  return !url ? true : stringMatchesSomePattern(url, allowUrls);\n}\n\nfunction _getPossibleEventMessages(event) {\n  if (event.message) {\n    return [event.message];\n  }\n  if (event.exception) {\n    try {\n      const { type = '', value = '' } = (event.exception.values && event.exception.values[0]) || {};\n      return [`${value}`, `${type}: ${value}`];\n    } catch (oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(`Cannot extract message for event ${getEventDescription(event)}`);\n      return [];\n    }\n  }\n  return [];\n}\n\nfunction _isSentryError(event) {\n  try {\n    // @ts-ignore can't be a sentry error if undefined\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return event.exception.values[0].type === 'SentryError';\n  } catch (e) {\n    // ignore\n  }\n  return false;\n}\n\nfunction _getLastValidUrl(frames = []) {\n  for (let i = frames.length - 1; i >= 0; i--) {\n    const frame = frames[i];\n\n    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n      return frame.filename || null;\n    }\n  }\n\n  return null;\n}\n\nfunction _getEventFilterUrl(event) {\n  try {\n    let frames;\n    try {\n      // @ts-ignore we only care about frames if the whole thing here is defined\n      frames = event.exception.values[0].stacktrace.frames;\n    } catch (e) {\n      // ignore\n    }\n    return frames ? _getLastValidUrl(frames) : null;\n  } catch (oO) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);\n    return null;\n  }\n}\n\nexport { InboundFilters, _mergeOptions, _shouldDropEvent };\n//# sourceMappingURL=inboundfilters.js.map\n","import { getOriginalFunction } from '@sentry/utils';\n\nlet originalFunctionToString;\n\n/** Patch toString calls to return proper name for wrapped functions */\nclass FunctionToString  {constructor() { FunctionToString.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'FunctionToString';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = FunctionToString.id;}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    originalFunctionToString = Function.prototype.toString;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Function.prototype.toString = function ( ...args) {\n      const context = getOriginalFunction(this) || this;\n      return originalFunctionToString.apply(context, args);\n    };\n  }\n} FunctionToString.__initStatic();\n\nexport { FunctionToString };\n//# sourceMappingURL=functiontostring.js.map\n","import { arrayify, logger } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\nimport { addGlobalEventProcessor } from './scope.js';\n\nconst installedIntegrations = [];\n\n/** Map of integrations assigned to a client */\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preseve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations) {\n  const integrationsByName = {};\n\n  integrations.forEach(currentInstance => {\n    const { name } = currentInstance;\n\n    const existingInstance = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nfunction getIntegrationsToSetup(options) {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach(integration => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations;\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = arrayify(userIntegrations(defaultIntegrations));\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  const finalIntegrations = filterDuplicates(integrations);\n\n  // The `Debug` integration prints copies of the `event` and `hint` which will be passed to `beforeSend` or\n  // `beforeSendTransaction`. It therefore has to run after all other integrations, so that the changes of all event\n  // processors will be reflected in the printed values. For lack of a more elegant way to guarantee that, we therefore\n  // locate it and, assuming it exists, pop it out of its current spot and shove it onto the end of the array.\n  const debugIndex = finalIntegrations.findIndex(integration => integration.name === 'Debug');\n  if (debugIndex !== -1) {\n    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);\n    finalIntegrations.push(debugInstance);\n  }\n\n  return finalIntegrations;\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nfunction setupIntegrations(integrations) {\n  const integrationIndex = {};\n\n  integrations.forEach(integration => {\n    integrationIndex[integration.name] = integration;\n\n    if (installedIntegrations.indexOf(integration.name) === -1) {\n      integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n      installedIntegrations.push(integration.name);\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Integration installed: ${integration.name}`);\n    }\n  });\n\n  return integrationIndex;\n}\n\nexport { getIntegrationsToSetup, installedIntegrations, setupIntegrations };\n//# sourceMappingURL=integration.js.map\n","import { logger } from '@sentry/utils';\nimport { getCurrentHub } from './hub.js';\n\n/** A class object that can instantiate Client objects. */\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instantiate.\n * @param options Options to pass to the client.\n */\nfunction initAndBind(\n  clientClass,\n  options,\n) {\n  if (options.debug === true) {\n    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n      logger.enable();\n    } else {\n      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped\n      // eslint-disable-next-line no-console\n      console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');\n    }\n  }\n  const hub = getCurrentHub();\n  const scope = hub.getScope();\n  if (scope) {\n    scope.update(options.initialScope);\n  }\n\n  const client = new clientClass(options);\n  hub.bindClient(client);\n}\n\nexport { initAndBind };\n//# sourceMappingURL=sdk.js.map\n","import { _optionalChain } from './buildPolyfills';\n\nconst STACKTRACE_LIMIT = 50;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nfunction createStackParser(...parsers) {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack, skipFirst = 0) => {\n    const frames = [];\n\n    for (const line of stack.split('\\n').slice(skipFirst)) {\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = line.replace(/\\(error: (.*)\\)/, '$1');\n\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames);\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nfunction stackParserFromStackParserOptions(stackParser) {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * @hidden\n */\nfunction stripSentryFramesAndReverse(stack) {\n  if (!stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  const firstFrameFunction = localStack[0].function || '';\n  const lastFrameFunction = localStack[localStack.length - 1].function || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(frame => ({\n      ...frame,\n      filename: frame.filename || localStack[0].filename,\n      function: frame.function || '?',\n    }))\n    .reverse();\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nfunction getFunctionName(fn) {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n// eslint-disable-next-line complexity\nfunction node(getModule) {\n  const FILENAME_MATCH = /^\\s*[-]{4,}$/;\n  const FULL_MATCH = /at (?:async )?(?:(.+?)\\s+\\()?(?:(.+):(\\d+):(\\d+)?|([^)]+))\\)?/;\n\n  // eslint-disable-next-line complexity\n  return (line) => {\n    if (line.match(FILENAME_MATCH)) {\n      return {\n        filename: line,\n      };\n    }\n\n    const lineMatch = line.match(FULL_MATCH);\n    if (!lineMatch) {\n      return undefined;\n    }\n\n    let object;\n    let method;\n    let functionName;\n    let typeName;\n    let methodName;\n\n    if (lineMatch[1]) {\n      functionName = lineMatch[1];\n\n      let methodStart = functionName.lastIndexOf('.');\n      if (functionName[methodStart - 1] === '.') {\n        methodStart--;\n      }\n\n      if (methodStart > 0) {\n        object = functionName.substr(0, methodStart);\n        method = functionName.substr(methodStart + 1);\n        const objectEnd = object.indexOf('.Module');\n        if (objectEnd > 0) {\n          functionName = functionName.substr(objectEnd + 1);\n          object = object.substr(0, objectEnd);\n        }\n      }\n      typeName = undefined;\n    }\n\n    if (method) {\n      typeName = object;\n      methodName = method;\n    }\n\n    if (method === '<anonymous>') {\n      methodName = undefined;\n      functionName = undefined;\n    }\n\n    if (functionName === undefined) {\n      methodName = methodName || '<anonymous>';\n      functionName = typeName ? `${typeName}.${methodName}` : methodName;\n    }\n\n    const filename = _optionalChain([lineMatch, 'access', _ => _[2], 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3('file://')]) ? lineMatch[2].substr(7) : lineMatch[2];\n    const isNative = lineMatch[5] === 'native';\n    const isInternal =\n      isNative || (filename && !filename.startsWith('/') && !filename.startsWith('.') && filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    const in_app = !isInternal && filename !== undefined && !filename.includes('node_modules/');\n\n    return {\n      filename,\n      module: _optionalChain([getModule, 'optionalCall', _4 => _4(filename)]),\n      function: functionName,\n      lineno: parseInt(lineMatch[3], 10) || undefined,\n      colno: parseInt(lineMatch[4], 10) || undefined,\n      in_app,\n    };\n  };\n}\n\n/**\n * Node.js stack line parser\n *\n * This is in @sentry/utils so it can be used from the Electron SDK in the browser for when `nodeIntegration == true`.\n * This allows it to be used without referencing or importing any node specific code which causes bundlers to complain\n */\nfunction nodeStackLineParser(getModule) {\n  return [90, node(getModule)];\n}\n\nexport { createStackParser, getFunctionName, nodeStackLineParser, stackParserFromStackParserOptions, stripSentryFramesAndReverse };\n//# sourceMappingURL=stacktrace.js.map\n","/** An error emitted by Sentry SDKs and related utilities. */\nclass SentryError extends Error {\n  /** Display name of this error instance. */\n\n   constructor( message, logLevel = 'warn') {\n    super(message);this.message = message;;\n\n    this.name = new.target.prototype.constructor.name;\n    // This sets the prototype to be `Error`, not `SentryError`. It's unclear why we do this, but commenting this line\n    // out causes various (seemingly totally unrelated) playwright tests consistently time out. FYI, this makes\n    // instances of `SentryError` fail `obj instanceof SentryError` checks.\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.logLevel = logLevel;\n  }\n}\n\nexport { SentryError };\n//# sourceMappingURL=error.js.map\n","import { SentryError } from './error.js';\n\n/** Regular expression used to parse a Dsn. */\nconst DSN_REGEX = /^(?:(\\w+):)\\/\\/(?:(\\w+)(?::(\\w+)?)?@)([\\w.-]+)(?::(\\d+))?\\/(.+)/;\n\nfunction isValidProtocol(protocol) {\n  return protocol === 'http' || protocol === 'https';\n}\n\n/**\n * Renders the string representation of this Dsn.\n *\n * By default, this will render the public representation without the password\n * component. To get the deprecated private representation, set `withPassword`\n * to true.\n *\n * @param withPassword When set to true, the password will be included.\n */\nfunction dsnToString(dsn, withPassword = false) {\n  const { host, path, pass, port, projectId, protocol, publicKey } = dsn;\n  return (\n    `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ''}` +\n    `@${host}${port ? `:${port}` : ''}/${path ? `${path}/` : path}${projectId}`\n  );\n}\n\n/**\n * Parses a Dsn from a given string.\n *\n * @param str A Dsn as string\n * @returns Dsn as DsnComponents\n */\nfunction dsnFromString(str) {\n  const match = DSN_REGEX.exec(str);\n\n  if (!match) {\n    throw new SentryError(`Invalid Sentry Dsn: ${str}`);\n  }\n\n  const [protocol, publicKey, pass = '', host, port = '', lastPath] = match.slice(1);\n  let path = '';\n  let projectId = lastPath;\n\n  const split = projectId.split('/');\n  if (split.length > 1) {\n    path = split.slice(0, -1).join('/');\n    projectId = split.pop() ;\n  }\n\n  if (projectId) {\n    const projectMatch = projectId.match(/^\\d+/);\n    if (projectMatch) {\n      projectId = projectMatch[0];\n    }\n  }\n\n  return dsnFromComponents({ host, pass, path, projectId, port, protocol: protocol , publicKey });\n}\n\nfunction dsnFromComponents(components) {\n  return {\n    protocol: components.protocol,\n    publicKey: components.publicKey || '',\n    pass: components.pass || '',\n    host: components.host,\n    port: components.port || '',\n    path: components.path || '',\n    projectId: components.projectId,\n  };\n}\n\nfunction validateDsn(dsn) {\n  if (!(typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n    return;\n  }\n\n  const { port, projectId, protocol } = dsn;\n\n  const requiredComponents = ['protocol', 'publicKey', 'host', 'projectId'];\n  requiredComponents.forEach(component => {\n    if (!dsn[component]) {\n      throw new SentryError(`Invalid Sentry Dsn: ${component} missing`);\n    }\n  });\n\n  if (!projectId.match(/^\\d+$/)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);\n  }\n\n  if (!isValidProtocol(protocol)) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);\n  }\n\n  if (port && isNaN(parseInt(port, 10))) {\n    throw new SentryError(`Invalid Sentry Dsn: Invalid port ${port}`);\n  }\n\n  return true;\n}\n\n/** The Sentry Dsn, identifying a Sentry instance and project. */\nfunction makeDsn(from) {\n  const components = typeof from === 'string' ? dsnFromString(from) : dsnFromComponents(from);\n  validateDsn(components);\n  return components;\n}\n\nexport { dsnFromString, dsnToString, makeDsn };\n//# sourceMappingURL=dsn.js.map\n","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Helper to decycle json objects\n */\nfunction memoBuilder() {\n  const hasWeakSet = typeof WeakSet === 'function';\n  const inner = hasWeakSet ? new WeakSet() : [];\n  function memoize(obj) {\n    if (hasWeakSet) {\n      if (inner.has(obj)) {\n        return true;\n      }\n      inner.add(obj);\n      return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < inner.length; i++) {\n      const value = inner[i];\n      if (value === obj) {\n        return true;\n      }\n    }\n    inner.push(obj);\n    return false;\n  }\n\n  function unmemoize(obj) {\n    if (hasWeakSet) {\n      inner.delete(obj);\n    } else {\n      for (let i = 0; i < inner.length; i++) {\n        if (inner[i] === obj) {\n          inner.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  return [memoize, unmemoize];\n}\n\nexport { memoBuilder };\n//# sourceMappingURL=memo.js.map\n","import { isNaN, isSyntheticEvent } from './is.js';\nimport { memoBuilder } from './memo.js';\nimport { convertToPlainObject } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normallized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction normalize(input, depth = +Infinity, maxProperties = +Infinity) {\n  try {\n    // since we're at the outermost level, we don't provide a key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nfunction normalizeToSize(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object,\n  // Default Node.js REPL depth\n  depth = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize = 100 * 1024,\n) {\n  const normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized ;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key,\n  value,\n  depth = +Infinity,\n  maxProperties = +Infinity,\n  memo = memoBuilder(),\n) {\n  const [memoize, unmemoize] = memo;\n\n  // Get the simple cases out of the way first\n  if (value === null || (['number', 'boolean', 'string'].includes(typeof value) && !isNaN(value))) {\n    return value ;\n  }\n\n  const stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // From here on, we can assert that `value` is either an object or an array.\n\n  // Do not normalize objects that we know have already been normalized. As a general rule, the\n  // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n  // have already been normalized.\n  if ((value )['__sentry_skip_normalization__']) {\n    return value ;\n  }\n\n  // We're also done if we've reached the max depth\n  if (depth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // If the value has a `toJSON` method, we call it to extract more information\n  const valueWithToJSON = value ;\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      const jsonValue = valueWithToJSON.toJSON();\n      // We need to normalize the return value of `.toJSON()` in case it has circular references\n      return visit('', jsonValue, depth - 1, maxProperties, memo);\n    } catch (err) {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  const normalized = (Array.isArray(value) ? [] : {}) ;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  const visitable = convertToPlainObject(value );\n\n  for (const visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    const visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, depth - 1, maxProperties, memo);\n\n    numAdded++;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value,\n) {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value )._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof global !== 'undefined' && value === global) {\n      return '[Global]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    // React's SyntheticEvent thingy\n    if (isSyntheticEvent(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && value !== value) {\n      return '[NaN]';\n    }\n\n    // this catches `undefined` (but not `null`, which is a primitive and can be serialized on its own)\n    if (value === void 0) {\n      return '[undefined]';\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${getFunctionName(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    return `[object ${(Object.getPrototypeOf(value) ).constructor.name}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n\nexport { normalize, normalizeToSize, visit as walk };\n//# sourceMappingURL=normalize.js.map\n","import { normalize } from './normalize.js';\nimport { dropUndefinedKeys } from './object.js';\n\n/**\n * Creates an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction createEnvelope(headers, items = []) {\n  return [headers, items] ;\n}\n\n/**\n * Add an item to an envelope.\n * Make sure to always explicitly provide the generic to this function\n * so that the envelope types resolve correctly.\n */\nfunction addItemToEnvelope(envelope, newItem) {\n  const [headers, items] = envelope;\n  return [headers, [...items, newItem]] ;\n}\n\n/**\n * Convenience function to loop through the items and item types of an envelope.\n * (This function was mostly created because working with envelope types is painful at the moment)\n */\nfunction forEachEnvelopeItem(\n  envelope,\n  callback,\n) {\n  const envelopeItems = envelope[1];\n  envelopeItems.forEach((envelopeItem) => {\n    const envelopeItemType = envelopeItem[0].type;\n    callback(envelopeItem, envelopeItemType);\n  });\n}\n\nfunction encodeUTF8(input, textEncoder) {\n  const utf8 = textEncoder || new TextEncoder();\n  return utf8.encode(input);\n}\n\n/**\n * Serializes an envelope.\n */\nfunction serializeEnvelope(envelope, textEncoder) {\n  const [envHeaders, items] = envelope;\n\n  // Initially we construct our envelope as a string and only convert to binary chunks if we encounter binary data\n  let parts = JSON.stringify(envHeaders);\n\n  function append(next) {\n    if (typeof parts === 'string') {\n      parts = typeof next === 'string' ? parts + next : [encodeUTF8(parts, textEncoder), next];\n    } else {\n      parts.push(typeof next === 'string' ? encodeUTF8(next, textEncoder) : next);\n    }\n  }\n\n  for (const item of items) {\n    const [itemHeaders, payload] = item;\n\n    append(`\\n${JSON.stringify(itemHeaders)}\\n`);\n\n    if (typeof payload === 'string' || payload instanceof Uint8Array) {\n      append(payload);\n    } else {\n      let stringifiedPayload;\n      try {\n        stringifiedPayload = JSON.stringify(payload);\n      } catch (e) {\n        // In case, despite all our efforts to keep `payload` circular-dependency-free, `JSON.strinify()` still\n        // fails, we try again after normalizing it again with infinite normalization depth. This of course has a\n        // performance impact but in this case a performance hit is better than throwing.\n        stringifiedPayload = JSON.stringify(normalize(payload));\n      }\n      append(stringifiedPayload);\n    }\n  }\n\n  return typeof parts === 'string' ? parts : concatBuffers(parts);\n}\n\nfunction concatBuffers(buffers) {\n  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);\n\n  const merged = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buffer of buffers) {\n    merged.set(buffer, offset);\n    offset += buffer.length;\n  }\n\n  return merged;\n}\n\n/**\n * Creates attachment envelope items\n */\nfunction createAttachmentEnvelopeItem(\n  attachment,\n  textEncoder,\n) {\n  const buffer = typeof attachment.data === 'string' ? encodeUTF8(attachment.data, textEncoder) : attachment.data;\n\n  return [\n    dropUndefinedKeys({\n      type: 'attachment',\n      length: buffer.length,\n      filename: attachment.filename,\n      content_type: attachment.contentType,\n      attachment_type: attachment.attachmentType,\n    }),\n    buffer,\n  ];\n}\n\nconst ITEM_TYPE_TO_DATA_CATEGORY_MAP = {\n  session: 'session',\n  sessions: 'session',\n  attachment: 'attachment',\n  transaction: 'transaction',\n  event: 'error',\n  client_report: 'internal',\n  user_report: 'default',\n};\n\n/**\n * Maps the type of an envelope item to a data category.\n */\nfunction envelopeItemTypeToDataCategory(type) {\n  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];\n}\n\nexport { addItemToEnvelope, createAttachmentEnvelopeItem, createEnvelope, envelopeItemTypeToDataCategory, forEachEnvelopeItem, serializeEnvelope };\n//# sourceMappingURL=envelope.js.map\n","import { urlEncode, makeDsn, dsnToString } from '@sentry/utils';\n\nconst SENTRY_API_VERSION = '7';\n\n/** Returns the prefix to construct Sentry ingestion API endpoints. */\nfunction getBaseApiEndpoint(dsn) {\n  const protocol = dsn.protocol ? `${dsn.protocol}:` : '';\n  const port = dsn.port ? `:${dsn.port}` : '';\n  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;\n}\n\n/** Returns the ingest API endpoint for target. */\nfunction _getIngestEndpoint(dsn) {\n  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;\n}\n\n/** Returns a URL-encoded string with auth config suitable for a query string. */\nfunction _encodedAuth(dsn, sdkInfo) {\n  return urlEncode({\n    // We send only the minimum set of required information. See\n    // https://github.com/getsentry/sentry-javascript/issues/2572.\n    sentry_key: dsn.publicKey,\n    sentry_version: SENTRY_API_VERSION,\n    ...(sdkInfo && { sentry_client: `${sdkInfo.name}/${sdkInfo.version}` }),\n  });\n}\n\n/**\n * Returns the envelope endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nfunction getEnvelopeEndpointWithUrlEncodedAuth(\n  dsn,\n  // TODO (v8): Remove `tunnelOrOptions` in favor of `options`, and use the substitute code below\n  // options: ClientOptions = {} as ClientOptions,\n  tunnelOrOptions = {} ,\n) {\n  // TODO (v8): Use this code instead\n  // const { tunnel, _metadata = {} } = options;\n  // return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, _metadata.sdk)}`;\n\n  const tunnel = typeof tunnelOrOptions === 'string' ? tunnelOrOptions : tunnelOrOptions.tunnel;\n  const sdkInfo =\n    typeof tunnelOrOptions === 'string' || !tunnelOrOptions._metadata ? undefined : tunnelOrOptions._metadata.sdk;\n\n  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;\n}\n\n/** Returns the url to the report dialog endpoint. */\nfunction getReportDialogEndpoint(\n  dsnLike,\n  dialogOptions\n\n,\n) {\n  const dsn = makeDsn(dsnLike);\n  const endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;\n\n  let encodedOptions = `dsn=${dsnToString(dsn)}`;\n  for (const key in dialogOptions) {\n    if (key === 'dsn') {\n      continue;\n    }\n\n    if (key === 'user') {\n      const user = dialogOptions.user;\n      if (!user) {\n        continue;\n      }\n      if (user.name) {\n        encodedOptions += `&name=${encodeURIComponent(user.name)}`;\n      }\n      if (user.email) {\n        encodedOptions += `&email=${encodeURIComponent(user.email)}`;\n      }\n    } else {\n      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] )}`;\n    }\n  }\n\n  return `${endpoint}?${encodedOptions}`;\n}\n\nexport { getEnvelopeEndpointWithUrlEncodedAuth, getReportDialogEndpoint };\n//# sourceMappingURL=api.js.map\n","import { dsnToString, createEnvelope, dropUndefinedKeys } from '@sentry/utils';\n\n/** Extract sdk info from from the API metadata */\nfunction getSdkMetadataForEnvelopeHeader(metadata) {\n  if (!metadata || !metadata.sdk) {\n    return;\n  }\n  const { name, version } = metadata.sdk;\n  return { name, version };\n}\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n **/\nfunction enhanceEventWithSdkInfo(event, sdkInfo) {\n  if (!sdkInfo) {\n    return event;\n  }\n  event.sdk = event.sdk || {};\n  event.sdk.name = event.sdk.name || sdkInfo.name;\n  event.sdk.version = event.sdk.version || sdkInfo.version;\n  event.sdk.integrations = [...(event.sdk.integrations || []), ...(sdkInfo.integrations || [])];\n  event.sdk.packages = [...(event.sdk.packages || []), ...(sdkInfo.packages || [])];\n  return event;\n}\n\n/** Creates an envelope from a Session */\nfunction createSessionEnvelope(\n  session,\n  dsn,\n  metadata,\n  tunnel,\n) {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  const envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsnToString(dsn) }),\n  };\n\n  const envelopeItem =\n    'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session];\n\n  return createEnvelope(envelopeHeaders, [envelopeItem]);\n}\n\n/**\n * Create an Envelope from an event.\n */\nfunction createEventEnvelope(\n  event,\n  dsn,\n  metadata,\n  tunnel,\n) {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  const eventType = event.type || 'event';\n\n  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);\n\n  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete event.sdkProcessingMetadata;\n\n  const eventItem = [{ type: eventType }, event];\n  return createEnvelope(envelopeHeaders, [eventItem]);\n}\n\nfunction createEventEnvelopeHeaders(\n  event,\n  sdkInfo,\n  tunnel,\n  dsn,\n) {\n  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;\n\n  return {\n    event_id: event.event_id ,\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && { dsn: dsnToString(dsn) }),\n    ...(event.type === 'transaction' &&\n      dynamicSamplingContext && {\n        trace: dropUndefinedKeys({ ...dynamicSamplingContext }),\n      }),\n  };\n}\n\nexport { createEventEnvelope, createSessionEnvelope };\n//# sourceMappingURL=envelope.js.map\n","import { makeDsn, logger, checkOrSetAlreadyCaught, isPrimitive, resolvedSyncPromise, addItemToEnvelope, createAttachmentEnvelopeItem, SyncPromise, uuid4, dateTimestampInSeconds, normalize, truncate, rejectedSyncPromise, SentryError, isThenable, isPlainObject } from '@sentry/utils';\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api.js';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope.js';\nimport { setupIntegrations } from './integration.js';\nimport { Scope } from './scope.js';\nimport { updateSession } from './session.js';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nclass BaseClient {\n  /** Options passed to the SDK. */\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n\n  /** Array of set up integrations. */\n   __init() {this._integrations = {};}\n\n  /** Indicates whether this client's integrations have been set up. */\n   __init2() {this._integrationsInitialized = false;}\n\n  /** Number of calls being processed */\n   __init3() {this._numProcessing = 0;}\n\n  /** Holds flushable  */\n   __init4() {this._outcomes = {};}\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n   constructor(options) {;BaseClient.prototype.__init.call(this);BaseClient.prototype.__init2.call(this);BaseClient.prototype.__init3.call(this);BaseClient.prototype.__init4.call(this);\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);\n      this._transport = options.transport({\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('No DSN provided, client will not do anything.');\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n   captureException(exception, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId = hint && hint.event_id;\n\n    this._process(\n      this.eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureMessage(\n    message,\n    // eslint-disable-next-line deprecation/deprecation\n    level,\n    hint,\n    scope,\n  ) {\n    let eventId = hint && hint.event_id;\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(String(message), level, hint)\n      : this.eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureEvent(event, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   captureSession(session) {\n    if (!this._isEnabled()) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this.sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      updateSession(session, { init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getDsn() {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getOptions() {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTransport() {\n    return this._transport;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   flush(timeout) {\n    const transport = this._transport;\n    if (transport) {\n      return this._isClientDoneProcessing(timeout).then(clientFinished => {\n        return transport.flush(timeout).then(transportFlushed => clientFinished && transportFlushed);\n      });\n    } else {\n      return resolvedSyncPromise(true);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   close(timeout) {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n   setupIntegrations() {\n    if (this._isEnabled() && !this._integrationsInitialized) {\n      this._integrations = setupIntegrations(this._options.integrations);\n      this._integrationsInitialized = true;\n    }\n  }\n\n  /**\n   * Gets an installed integration by its `id`.\n   *\n   * @returns The installed integration or `undefined` if no integration with that `id` was installed.\n   */\n   getIntegrationById(integrationId) {\n    return this._integrations[integrationId];\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getIntegration(integration) {\n    try {\n      return (this._integrations[integration.id] ) || null;\n    } catch (_oO) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendEvent(event, hint = {}) {\n    if (this._dsn) {\n      let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n      for (const attachment of hint.attachments || []) {\n        env = addItemToEnvelope(\n          env,\n          createAttachmentEnvelopeItem(\n            attachment,\n            this._options.transportOptions && this._options.transportOptions.textEncoder,\n          ),\n        );\n      }\n\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendSession(session) {\n    if (this._dsn) {\n      const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n      this._sendEnvelope(env);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   recordDroppedEvent(reason, category, _event) {\n    // Note: we use `event` in replay, where we overwrite this hook.\n\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Adding outcome: \"${key}\"`);\n\n      // The following works because undefined + 1 === NaN and NaN is falsy\n      this._outcomes[key] = this._outcomes[key] + 1 || 1;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n   _updateSessionFromEvent(session, event) {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n   _isClientDoneProcessing(timeout) {\n    return new SyncPromise(resolve => {\n      let ticked = 0;\n      const tick = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n   _isEnabled() {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n   _prepareEvent(event, hint, scope) {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1000 } = this.getOptions();\n    const prepared = {\n      ...event,\n      event_id: event.event_id || hint.event_id || uuid4(),\n      timestamp: event.timestamp || dateTimestampInSeconds(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = resolvedSyncPromise(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    //\n    // We need to check for the existence of `finalScope.getAttachments`\n    // because `getAttachments` can be undefined if users are using an older version\n    // of `@sentry/core` that does not have the `getAttachments` method.\n    // See: https://github.com/getsentry/sentry-javascript/issues/5229\n    if (finalScope && finalScope.getAttachments) {\n      // Collect attachments from the hint and scope\n      const attachments = [...(hint.attachments || []), ...finalScope.getAttachments()];\n\n      if (attachments.length) {\n        hint.attachments = attachments;\n      }\n\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n   _normalizeEvent(event, depth, maxBreadth) {\n    if (!event) {\n      return null;\n    }\n\n    const normalized = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: normalize(b.data, depth, maxBreadth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: normalize(event.user, depth, maxBreadth),\n      }),\n      ...(event.contexts && {\n        contexts: normalize(event.contexts, depth, maxBreadth),\n      }),\n      ...(event.extra && {\n        extra: normalize(event.extra, depth, maxBreadth),\n      }),\n    };\n\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace && normalized.contexts) {\n      normalized.contexts.trace = event.contexts.trace;\n\n      // event.contexts.trace.data may contain circular/dangerous data so we need to normalize it\n      if (event.contexts.trace.data) {\n        normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth);\n      }\n    }\n\n    // event.spans[].data may contain circular/dangerous data so we need to normalize it\n    if (event.spans) {\n      normalized.spans = event.spans.map(span => {\n        // We cannot use the spread operator here because `toJSON` on `span` is non-enumerable\n        if (span.data) {\n          span.data = normalize(span.data, depth, maxBreadth);\n        }\n        return span;\n      });\n    }\n\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n   _applyClientOptions(event) {\n    const options = this.getOptions();\n    const { environment, release, dist, maxValueLength = 250 } = options;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    const request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param event The event that will be filled with all integrations.\n   */\n   _applyIntegrationsMetadata(event) {\n    const integrationsArray = Object.keys(this._integrations);\n    if (integrationsArray.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];\n    }\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n   _captureEvent(event, hint = {}, scope) {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {\n          // If something's gone wrong, log the error as a warning. If it's just us having used a `SentryError` for\n          // control flow, log just the message (no stack) as a log-level log.\n          const sentryError = reason ;\n          if (sentryError.logLevel === 'log') {\n            logger.log(sentryError.message);\n          } else {\n            logger.warn(sentryError);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n   _processEvent(event, hint, scope) {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.', 'log'));\n    }\n\n    const isTransaction = event.type === 'transaction';\n    const beforeSendProcessorName = isTransaction ? 'beforeSendTransaction' : 'beforeSend';\n    const beforeSendProcessor = options[beforeSendProcessorName];\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error', event);\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n          'log',\n        ),\n      );\n    }\n\n    return this._prepareEvent(event, hint, scope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', event.type || 'error', event);\n          throw new SentryError('An event processor returned `null`, will not send event.', 'log');\n        }\n\n        const isInternalException = hint.data && (hint.data ).__sentry__ === true;\n        if (isInternalException || !beforeSendProcessor) {\n          return prepared;\n        }\n\n        const beforeSendResult = beforeSendProcessor(prepared, hint);\n        return _validateBeforeSendResult(beforeSendResult, beforeSendProcessorName);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', event.type || 'error', event);\n          throw new SentryError(`\\`${beforeSendProcessorName}\\` returned \\`null\\`, will not send event.`, 'log');\n        }\n\n        const session = scope && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n            changes: [\n              ...transactionInfo.changes,\n              {\n                source,\n                // use the same timestamp as the processed event.\n                timestamp: processedEvent.timestamp ,\n                propagations: transactionInfo.propagations,\n              },\n            ],\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason ,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n   _process(promise) {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n   _sendEnvelope(envelope) {\n    if (this._transport && this._dsn) {\n      this._transport.send(envelope).then(null, reason => {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Error while sending event:', reason);\n      });\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Transport disabled');\n    }\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n   _clearOutcomes() {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.keys(outcomes).map(key => {\n      const [reason, category] = key.split(':') ;\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult,\n  beforeSendProcessorName,\n) {\n  const invalidValueError = `\\`${beforeSendProcessorName}\\` must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw new SentryError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`\\`${beforeSendProcessorName}\\` rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw new SentryError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\nexport { BaseClient };\n//# sourceMappingURL=baseclient.js.map\n","import { createEnvelope } from './envelope.js';\nimport { dateTimestampInSeconds } from './time.js';\n\n/**\n * Creates client report envelope\n * @param discarded_events An array of discard events\n * @param dsn A DSN that can be set on the header. Optional.\n */\nfunction createClientReportEnvelope(\n  discarded_events,\n  dsn,\n  timestamp,\n) {\n  const clientReportItem = [\n    { type: 'client_report' },\n    {\n      timestamp: timestamp || dateTimestampInSeconds(),\n      discarded_events,\n    },\n  ];\n  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);\n}\n\nexport { createClientReportEnvelope };\n//# sourceMappingURL=clientreport.js.map\n","import { getCurrentHub } from '@sentry/core';\nimport { isEvent, extractExceptionKeysForMessage, normalizeToSize, addExceptionMechanism, resolvedSyncPromise, isErrorEvent, isDOMError, isDOMException, addExceptionTypeValue, isError, isPlainObject } from '@sentry/utils';\n\n/**\n * This function creates an exception from a JavaScript Error\n */\nfunction exceptionFromError(stackParser, ex) {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  const frames = parseStackFrames(stackParser, ex);\n\n  const exception = {\n    type: ex && ex.name,\n    value: extractMessage(ex),\n  };\n\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\n/**\n * @hidden\n */\nfunction eventFromPlainObject(\n  stackParser,\n  exception,\n  syntheticException,\n  isUnhandledRejection,\n) {\n  const hub = getCurrentHub();\n  const client = hub.getClient();\n  const normalizeDepth = client && client.getOptions().normalizeDepth;\n\n  const event = {\n    exception: {\n      values: [\n        {\n          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n          value: `Non-Error ${\n            isUnhandledRejection ? 'promise rejection' : 'exception'\n          } captured with keys: ${extractExceptionKeysForMessage(exception)}`,\n        },\n      ],\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception, normalizeDepth),\n    },\n  };\n\n  if (syntheticException) {\n    const frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      // event.exception.values[0] has been set above\n      (event.exception ).values[0].stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n\n/**\n * @hidden\n */\nfunction eventFromError(stackParser, ex) {\n  return {\n    exception: {\n      values: [exceptionFromError(stackParser, ex)],\n    },\n  };\n}\n\n/** Parses stack frames from an error */\nfunction parseStackFrames(\n  stackParser,\n  ex,\n) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  const stacktrace = ex.stacktrace || ex.stack || '';\n\n  const popSize = getPopSize(ex);\n\n  try {\n    return stackParser(stacktrace, popSize);\n  } catch (e) {\n    // no-empty\n  }\n\n  return [];\n}\n\n// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\nconst reactMinifiedRegexp = /Minified React error #\\d+;/i;\n\nfunction getPopSize(ex) {\n  if (ex) {\n    if (typeof ex.framesToPop === 'number') {\n      return ex.framesToPop;\n    }\n\n    if (reactMinifiedRegexp.test(ex.message)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\nfunction extractMessage(ex) {\n  const message = ex && ex.message;\n  if (!message) {\n    return 'No error message';\n  }\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n  return message;\n}\n\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\nfunction eventFromException(\n  stackParser,\n  exception,\n  hint,\n  attachStacktrace,\n) {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);\n  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }\n  event.level = 'error';\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nfunction eventFromMessage(\n  stackParser,\n  message,\n  // eslint-disable-next-line deprecation/deprecation\n  level = 'info',\n  hint,\n  attachStacktrace,\n) {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * @hidden\n */\nfunction eventFromUnknownInput(\n  stackParser,\n  exception,\n  syntheticException,\n  attachStacktrace,\n  isUnhandledRejection,\n) {\n  let event;\n\n  if (isErrorEvent(exception ) && (exception ).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    const errorEvent = exception ;\n    return eventFromError(stackParser, errorEvent.error );\n  }\n\n  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n  if (isDOMError(exception ) || isDOMException(exception )) {\n    const domException = exception ;\n\n    if ('stack' in (exception )) {\n      event = eventFromError(stackParser, exception );\n    } else {\n      const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      const message = domException.message ? `${name}: ${domException.message}` : name;\n      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);\n      addExceptionTypeValue(event, message);\n    }\n    if ('code' in domException) {\n      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };\n    }\n\n    return event;\n  }\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    return eventFromError(stackParser, exception);\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    const objectException = exception ;\n    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);\n    addExceptionMechanism(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(stackParser, exception , syntheticException, attachStacktrace);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\n/**\n * @hidden\n */\nfunction eventFromString(\n  stackParser,\n  input,\n  syntheticException,\n  attachStacktrace,\n) {\n  const event = {\n    message: input,\n  };\n\n  if (attachStacktrace && syntheticException) {\n    const frames = parseStackFrames(stackParser, syntheticException);\n    if (frames.length) {\n      event.exception = {\n        values: [{ value: input, stacktrace: { frames } }],\n      };\n    }\n  }\n\n  return event;\n}\n\nexport { eventFromError, eventFromException, eventFromMessage, eventFromPlainObject, eventFromString, eventFromUnknownInput, exceptionFromError, parseStackFrames };\n//# sourceMappingURL=eventbuilder.js.map\n","import { withScope, captureException } from '@sentry/core';\nimport { GLOBAL_OBJ, getOriginalFunction, addExceptionTypeValue, addExceptionMechanism, markFunctionWrapped, addNonEnumerableProperty } from '@sentry/utils';\n\nconst WINDOW = GLOBAL_OBJ ;\n\nlet ignoreOnError = 0;\n\n/**\n * @hidden\n */\nfunction shouldIgnoreOnError() {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nfunction ignoreNextOnError() {\n  // onerror should trigger before setTimeout\n  ignoreOnError++;\n  setTimeout(() => {\n    ignoreOnError--;\n  });\n}\n\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always\n * has a correct `this` context.\n * @returns The wrapped function.\n * @hidden\n */\nfunction wrap(\n  fn,\n  options\n\n = {},\n  before,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n  // for future readers what this does is wrap a function and then create\n  // a bi-directional wrapping between them.\n  //\n  // example: wrapped = wrap(original);\n  //  original.__sentry_wrapped__ -> wrapped\n  //  wrapped.__sentry_original__ -> original\n\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n\n  try {\n    // if we're dealing with a function that was previously wrapped, return\n    // the original wrapper.\n    const wrapper = fn.__sentry_wrapped__;\n    if (wrapper) {\n      return wrapper;\n    }\n\n    // We don't wanna wrap it twice\n    if (getOriginalFunction(fn)) {\n      return fn;\n    }\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n  /* eslint-disable prefer-rest-params */\n  // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`\n  const sentryWrapped = function () {\n    const args = Array.prototype.slice.call(arguments);\n\n    try {\n      if (before && typeof before === 'function') {\n        before.apply(this, arguments);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n      const wrappedArguments = args.map((arg) => wrap(arg, options));\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n    } catch (ex) {\n      ignoreNextOnError();\n\n      withScope((scope) => {\n        scope.addEventProcessor((event) => {\n          if (options.mechanism) {\n            addExceptionTypeValue(event, undefined, undefined);\n            addExceptionMechanism(event, options.mechanism);\n          }\n\n          event.extra = {\n            ...event.extra,\n            arguments: args,\n          };\n\n          return event;\n        });\n\n        captureException(ex);\n      });\n\n      throw ex;\n    }\n  };\n  /* eslint-enable prefer-rest-params */\n\n  // Accessing some objects may throw\n  // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  try {\n    for (const property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property] = fn[property];\n      }\n    }\n  } catch (_oO) {} // eslint-disable-line no-empty\n\n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  markFunctionWrapped(sentryWrapped, fn);\n\n  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name') ;\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get() {\n          return fn.name;\n        },\n      });\n    }\n    // eslint-disable-next-line no-empty\n  } catch (_oO) {}\n\n  return sentryWrapped;\n}\n\n/**\n * All properties the report dialog supports\n */\n\nexport { WINDOW, ignoreNextOnError, shouldIgnoreOnError, wrap };\n//# sourceMappingURL=helpers.js.map\n","// Note: Ideally the `SeverityLevel` type would be derived from `validSeverityLevels`, but that would mean either\n//\n// a) moving `validSeverityLevels` to `@sentry/types`,\n// b) moving the`SeverityLevel` type here, or\n// c) importing `validSeverityLevels` from here into `@sentry/types`.\n//\n// Option A would make `@sentry/types` a runtime dependency of `@sentry/utils` (not good), and options B and C would\n// create a circular dependency between `@sentry/types` and `@sentry/utils` (also not good). So a TODO accompanying the\n// type, reminding anyone who changes it to change this list also, will have to do.\n\nconst validSeverityLevels = ['fatal', 'error', 'warning', 'log', 'info', 'debug'];\n\n/**\n * Converts a string-based level into a member of the deprecated {@link Severity} enum.\n *\n * @deprecated `severityFromString` is deprecated. Please use `severityLevelFromString` instead.\n *\n * @param level String representation of Severity\n * @returns Severity\n */\nfunction severityFromString(level) {\n  return severityLevelFromString(level) ;\n}\n\n/**\n * Converts a string-based level into a `SeverityLevel`, normalizing it along the way.\n *\n * @param level String representation of desired `SeverityLevel`.\n * @returns The `SeverityLevel` corresponding to the given string, or 'log' if the string isn't a valid level.\n */\nfunction severityLevelFromString(level) {\n  return (level === 'warn' ? 'warning' : validSeverityLevels.includes(level) ? level : 'log') ;\n}\n\nexport { severityFromString, severityLevelFromString, validSeverityLevels };\n//# sourceMappingURL=severity.js.map\n","/**\n * Parses string form of URL into an object\n * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B\n * // intentionally using regex and not <a/> href parsing trick because React Native and other\n * // environments where DOM might not be available\n * @returns parsed URL object\n */\nfunction parseUrl(url)\n\n {\n  if (!url) {\n    return {};\n  }\n\n  const match = url.match(/^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/);\n\n  if (!match) {\n    return {};\n  }\n\n  // coerce to undefined values to empty string so we don't get 'undefined'\n  const query = match[6] || '';\n  const fragment = match[8] || '';\n  return {\n    host: match[4],\n    path: match[5],\n    protocol: match[2],\n    relative: match[5] + query + fragment, // everything minus origin\n  };\n}\n\n/**\n * Strip the query string and fragment off of a given URL or path (if present)\n *\n * @param urlPath Full URL or path, including possible query string and/or fragment\n * @returns URL or path without query string or fragment\n */\nfunction stripUrlQueryAndFragment(urlPath) {\n  // eslint-disable-next-line no-useless-escape\n  return urlPath.split(/[\\?#]/, 1)[0];\n}\n\n/**\n * Returns number of URL segments of a passed string URL.\n */\nfunction getNumberOfUrlSegments(url) {\n  // split at '/' or at '\\/' to split regex urls correctly\n  return url.split(/\\\\?\\//).filter(s => s.length > 0 && s !== ',').length;\n}\n\nexport { getNumberOfUrlSegments, parseUrl, stripUrlQueryAndFragment };\n//# sourceMappingURL=url.js.map\n","import { getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, getEventDescription, logger, htmlTreeAsString, severityLevelFromString, safeJoin, parseUrl } from '@sentry/utils';\nimport { WINDOW } from '../helpers.js';\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\n\n/** maxStringLength gets capped to prevent 100 breadcrumbs exceeding 1MB event payload size */\nconst MAX_ALLOWED_STRING_LENGTH = 1024;\n\nconst BREADCRUMB_INTEGRATION_ID = 'Breadcrumbs';\n\n/**\n * Default Breadcrumbs instrumentations\n * TODO: Deprecated - with v6, this will be renamed to `Instrument`\n */\nclass Breadcrumbs  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = BREADCRUMB_INTEGRATION_ID;}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = Breadcrumbs.id;}\n\n  /**\n   * Options of the breadcrumbs integration.\n   */\n  // This field is public, because we use it in the browser client to check if the `sentry` option is enabled.\n\n  /**\n   * @inheritDoc\n   */\n   constructor(options) {;Breadcrumbs.prototype.__init.call(this);\n    this.options = {\n      console: true,\n      dom: true,\n      fetch: true,\n      history: true,\n      sentry: true,\n      xhr: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Instrument browser built-ins w/ breadcrumb capturing\n   *  - Console API\n   *  - DOM API (click/typing)\n   *  - XMLHttpRequest API\n   *  - Fetch API\n   *  - History API\n   */\n   setupOnce() {\n    if (this.options.console) {\n      addInstrumentationHandler('console', _consoleBreadcrumb);\n    }\n    if (this.options.dom) {\n      addInstrumentationHandler('dom', _domBreadcrumb(this.options.dom));\n    }\n    if (this.options.xhr) {\n      addInstrumentationHandler('xhr', _xhrBreadcrumb);\n    }\n    if (this.options.fetch) {\n      addInstrumentationHandler('fetch', _fetchBreadcrumb);\n    }\n    if (this.options.history) {\n      addInstrumentationHandler('history', _historyBreadcrumb);\n    }\n  }\n\n  /**\n   * Adds a breadcrumb for Sentry events or transactions if this option is enabled.\n   */\n   addSentryBreadcrumb(event) {\n    if (this.options.sentry) {\n      getCurrentHub().addBreadcrumb(\n        {\n          category: `sentry.${event.type === 'transaction' ? 'transaction' : 'event'}`,\n          event_id: event.event_id,\n          level: event.level,\n          message: getEventDescription(event),\n        },\n        {\n          event,\n        },\n      );\n    }\n  }\n} Breadcrumbs.__initStatic();\n\n/**\n * A HOC that creaes a function that creates breadcrumbs from DOM API calls.\n * This is a HOC so that we get access to dom options in the closure.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _domBreadcrumb(dom) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function _innerDomBreadcrumb(handlerData) {\n    let target;\n    let keyAttrs = typeof dom === 'object' ? dom.serializeAttribute : undefined;\n\n    let maxStringLength =\n      typeof dom === 'object' && typeof dom.maxStringLength === 'number' ? dom.maxStringLength : undefined;\n    if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn(\n          `\\`dom.maxStringLength\\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`,\n        );\n      maxStringLength = MAX_ALLOWED_STRING_LENGTH;\n    }\n\n    if (typeof keyAttrs === 'string') {\n      keyAttrs = [keyAttrs];\n    }\n\n    // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n    try {\n      target = handlerData.event.target\n        ? htmlTreeAsString(handlerData.event.target , { keyAttrs, maxStringLength })\n        : htmlTreeAsString(handlerData.event , { keyAttrs, maxStringLength });\n    } catch (e) {\n      target = '<unknown>';\n    }\n\n    if (target.length === 0) {\n      return;\n    }\n\n    getCurrentHub().addBreadcrumb(\n      {\n        category: `ui.${handlerData.name}`,\n        message: target,\n      },\n      {\n        event: handlerData.event,\n        name: handlerData.name,\n        global: handlerData.global,\n      },\n    );\n  }\n\n  return _innerDomBreadcrumb;\n}\n\n/**\n * Creates breadcrumbs from console API calls\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _consoleBreadcrumb(handlerData) {\n  // This is a hack to fix a Vue3-specific bug that causes an infinite loop of\n  // console warnings. This happens when a Vue template is rendered with\n  // an undeclared variable, which we try to stringify, ultimately causing\n  // Vue to issue another warning which repeats indefinitely.\n  // see: https://github.com/getsentry/sentry-javascript/pull/6010\n  // see: https://github.com/getsentry/sentry-javascript/issues/5916\n  for (let i = 0; i < handlerData.args.length; i++) {\n    if (handlerData.args[i] === 'ref=Ref<') {\n      handlerData.args[i + 1] = 'viewRef';\n      break;\n    }\n  }\n  const breadcrumb = {\n    category: 'console',\n    data: {\n      arguments: handlerData.args,\n      logger: 'console',\n    },\n    level: severityLevelFromString(handlerData.level),\n    message: safeJoin(handlerData.args, ' '),\n  };\n\n  if (handlerData.level === 'assert') {\n    if (handlerData.args[0] === false) {\n      breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), ' ') || 'console.assert'}`;\n      breadcrumb.data.arguments = handlerData.args.slice(1);\n    } else {\n      // Don't capture a breadcrumb for passed assertions\n      return;\n    }\n  }\n\n  getCurrentHub().addBreadcrumb(breadcrumb, {\n    input: handlerData.args,\n    level: handlerData.level,\n  });\n}\n\n/**\n * Creates breadcrumbs from XHR API calls\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _xhrBreadcrumb(handlerData) {\n  if (handlerData.endTimestamp) {\n    // We only capture complete, non-sentry requests\n    if (handlerData.xhr.__sentry_own_request__) {\n      return;\n    }\n\n    const { method, url, status_code, body } = handlerData.xhr.__sentry_xhr__ || {};\n\n    getCurrentHub().addBreadcrumb(\n      {\n        category: 'xhr',\n        data: {\n          method,\n          url,\n          status_code,\n        },\n        type: 'http',\n      },\n      {\n        xhr: handlerData.xhr,\n        input: body,\n      },\n    );\n\n    return;\n  }\n}\n\n/**\n * Creates breadcrumbs from fetch API calls\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _fetchBreadcrumb(handlerData) {\n  // We only capture complete fetch requests\n  if (!handlerData.endTimestamp) {\n    return;\n  }\n\n  if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {\n    // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)\n    return;\n  }\n\n  if (handlerData.error) {\n    getCurrentHub().addBreadcrumb(\n      {\n        category: 'fetch',\n        data: handlerData.fetchData,\n        level: 'error',\n        type: 'http',\n      },\n      {\n        data: handlerData.error,\n        input: handlerData.args,\n      },\n    );\n  } else {\n    getCurrentHub().addBreadcrumb(\n      {\n        category: 'fetch',\n        data: {\n          ...handlerData.fetchData,\n          status_code: handlerData.response.status,\n        },\n        type: 'http',\n      },\n      {\n        input: handlerData.args,\n        response: handlerData.response,\n      },\n    );\n  }\n}\n\n/**\n * Creates breadcrumbs from history API calls\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _historyBreadcrumb(handlerData) {\n  let from = handlerData.from;\n  let to = handlerData.to;\n  const parsedLoc = parseUrl(WINDOW.location.href);\n  let parsedFrom = parseUrl(from);\n  const parsedTo = parseUrl(to);\n\n  // Initial pushState doesn't provide `from` information\n  if (!parsedFrom.path) {\n    parsedFrom = parsedLoc;\n  }\n\n  // Use only the path component of the URL if the URL matches the current\n  // document (almost all the time when using pushState)\n  if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {\n    to = parsedTo.relative;\n  }\n  if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {\n    from = parsedFrom.relative;\n  }\n\n  getCurrentHub().addBreadcrumb({\n    category: 'navigation',\n    data: {\n      from,\n      to,\n    },\n  });\n}\n\nexport { BREADCRUMB_INTEGRATION_ID, Breadcrumbs };\n//# sourceMappingURL=breadcrumbs.js.map\n","import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { BaseClient, SDK_VERSION, getEnvelopeEndpointWithUrlEncodedAuth } from '@sentry/core';\nimport { logger, createClientReportEnvelope, dsnToString, serializeEnvelope } from '@sentry/utils';\nimport { eventFromException, eventFromMessage } from './eventbuilder.js';\nimport { WINDOW } from './helpers.js';\nimport { BREADCRUMB_INTEGRATION_ID } from './integrations/breadcrumbs.js';\n\n/**\n * The Sentry Browser SDK Client.\n *\n * @see BrowserOptions for documentation on configuration options.\n * @see SentryClient for usage documentation.\n */\nclass BrowserClient extends BaseClient {\n  /**\n   * Creates a new Browser SDK instance.\n   *\n   * @param options Configuration options for this SDK.\n   */\n   constructor(options) {\n    options._metadata = options._metadata || {};\n    options._metadata.sdk = options._metadata.sdk || {\n      name: 'sentry.javascript.browser',\n      packages: [\n        {\n          name: 'npm:@sentry/browser',\n          version: SDK_VERSION,\n        },\n      ],\n      version: SDK_VERSION,\n    };\n\n    super(options);\n\n    if (options.sendClientReports && WINDOW.document) {\n      WINDOW.document.addEventListener('visibilitychange', () => {\n        if (WINDOW.document.visibilityState === 'hidden') {\n          this._flushOutcomes();\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromException(exception, hint) {\n    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   eventFromMessage(\n    message,\n    // eslint-disable-next-line deprecation/deprecation\n    level = 'info',\n    hint,\n  ) {\n    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   sendEvent(event, hint) {\n    // We only want to add the sentry event breadcrumb when the user has the breadcrumb integration installed and\n    // activated its `sentry` option.\n    // We also do not want to use the `Breadcrumbs` class here directly, because we do not want it to be included in\n    // bundles, if it is not used by the SDK.\n    // This all sadly is a bit ugly, but we currently don't have a \"pre-send\" hook on the integrations so we do it this\n    // way for now.\n    const breadcrumbIntegration = this.getIntegrationById(BREADCRUMB_INTEGRATION_ID) ;\n    // We check for definedness of `addSentryBreadcrumb` in case users provided their own integration with id\n    // \"Breadcrumbs\" that does not have this function.\n    _optionalChain([breadcrumbIntegration, 'optionalAccess', _ => _.addSentryBreadcrumb, 'optionalCall', _2 => _2(event)]);\n\n    super.sendEvent(event, hint);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   _prepareEvent(event, hint, scope) {\n    event.platform = event.platform || 'javascript';\n    return super._prepareEvent(event, hint, scope);\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n   _flushOutcomes() {\n    const outcomes = this._clearOutcomes();\n\n    if (outcomes.length === 0) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('No outcomes to send');\n      return;\n    }\n\n    if (!this._dsn) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('No dsn provided, will not send outcomes');\n      return;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Sending outcomes:', outcomes);\n\n    const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, this._options);\n    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));\n\n    try {\n      const isRealNavigator = Object.prototype.toString.call(WINDOW && WINDOW.navigator) === '[object Navigator]';\n      const hasSendBeacon = isRealNavigator && typeof WINDOW.navigator.sendBeacon === 'function';\n      // Make sure beacon is not used if user configures custom transport options\n      if (hasSendBeacon && !this._options.transportOptions) {\n        // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch\n        const sendBeacon = WINDOW.navigator.sendBeacon.bind(WINDOW.navigator);\n        sendBeacon(url, serializeEnvelope(envelope));\n      } else {\n        // If beacon is not supported or if they are using the tunnel option\n        // use our regular transport to send client reports to Sentry.\n        this._sendEnvelope(envelope);\n      }\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error(e);\n    }\n  }\n}\n\nexport { BrowserClient };\n//# sourceMappingURL=client.js.map\n","import { createStackParser } from '@sentry/utils';\n\n// global reference to slice\nconst UNKNOWN_FUNCTION = '?';\n\nconst OPERA10_PRIORITY = 10;\nconst OPERA11_PRIORITY = 20;\nconst CHROME_PRIORITY = 30;\nconst WINJS_PRIORITY = 40;\nconst GECKO_PRIORITY = 50;\n\nfunction createFrame(filename, func, lineno, colno) {\n  const frame = {\n    filename,\n    function: func,\n    // All browser frames are considered in_app\n    in_app: true,\n  };\n\n  if (lineno !== undefined) {\n    frame.lineno = lineno;\n  }\n\n  if (colno !== undefined) {\n    frame.colno = colno;\n  }\n\n  return frame;\n}\n\n// Chromium based browsers: Chrome, Brave, new Opera, new Edge\nconst chromeRegex =\n  /^\\s*at (?:(.*\\).*?|.*?) ?\\((?:address at )?)?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nconst chrome = line => {\n  const parts = chromeRegex.exec(line);\n\n  if (parts) {\n    const isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n    if (isEval) {\n      const subMatch = chromeEvalRegex.exec(parts[2]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line/column number\n        parts[2] = subMatch[1]; // url\n        parts[3] = subMatch[2]; // line\n        parts[4] = subMatch[3]; // column\n      }\n    }\n\n    // Kamil: One more hack won't hurt us right? Understanding and adding more rules on top of these regexps right now\n    // would be way too time consuming. (TODO: Rewrite whole RegExp to be more readable)\n    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n\n    return createFrame(filename, func, parts[3] ? +parts[3] : undefined, parts[4] ? +parts[4] : undefined);\n  }\n\n  return;\n};\n\nconst chromeStackLineParser = [CHROME_PRIORITY, chrome];\n\n// gecko regex: `(?:bundle|\\d+\\.js)`: `bundle` is for react native, `\\d+\\.js` also but specifically for ram bundles because it\n// generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js\n// We need this specific case for now because we want no other regex to match.\nconst geckoREgex =\n  /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|safari-extension|safari-web-extension|capacitor)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nconst gecko = line => {\n  const parts = geckoREgex.exec(line);\n\n  if (parts) {\n    const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n    if (isEval) {\n      const subMatch = geckoEvalRegex.exec(parts[3]);\n\n      if (subMatch) {\n        // throw out eval line/column and use top-most line number\n        parts[1] = parts[1] || 'eval';\n        parts[3] = subMatch[1];\n        parts[4] = subMatch[2];\n        parts[5] = ''; // no column when eval\n      }\n    }\n\n    let filename = parts[3];\n    let func = parts[1] || UNKNOWN_FUNCTION;\n    [func, filename] = extractSafariExtensionDetails(func, filename);\n\n    return createFrame(filename, func, parts[4] ? +parts[4] : undefined, parts[5] ? +parts[5] : undefined);\n  }\n\n  return;\n};\n\nconst geckoStackLineParser = [GECKO_PRIORITY, gecko];\n\nconst winjsRegex =\n  /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nconst winjs = line => {\n  const parts = winjsRegex.exec(line);\n\n  return parts\n    ? createFrame(parts[2], parts[1] || UNKNOWN_FUNCTION, +parts[3], parts[4] ? +parts[4] : undefined)\n    : undefined;\n};\n\nconst winjsStackLineParser = [WINJS_PRIORITY, winjs];\n\nconst opera10Regex = / line (\\d+).*script (?:in )?(\\S+)(?:: in function (\\S+))?$/i;\n\nconst opera10 = line => {\n  const parts = opera10Regex.exec(line);\n  return parts ? createFrame(parts[2], parts[3] || UNKNOWN_FUNCTION, +parts[1]) : undefined;\n};\n\nconst opera10StackLineParser = [OPERA10_PRIORITY, opera10];\n\nconst opera11Regex =\n  / line (\\d+), column (\\d+)\\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\\(.*\\))? in (.*):\\s*$/i;\n\nconst opera11 = line => {\n  const parts = opera11Regex.exec(line);\n  return parts ? createFrame(parts[5], parts[3] || parts[4] || UNKNOWN_FUNCTION, +parts[1], +parts[2]) : undefined;\n};\n\nconst opera11StackLineParser = [OPERA11_PRIORITY, opera11];\n\nconst defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser, winjsStackLineParser];\n\nconst defaultStackParser = createStackParser(...defaultStackLineParsers);\n\n/**\n * Safari web extensions, starting version unknown, can produce \"frames-only\" stacktraces.\n * What it means, is that instead of format like:\n *\n * Error: wat\n *   at function@url:row:col\n *   at function@url:row:col\n *   at function@url:row:col\n *\n * it produces something like:\n *\n *   function@url:row:col\n *   function@url:row:col\n *   function@url:row:col\n *\n * Because of that, it won't be captured by `chrome` RegExp and will fall into `Gecko` branch.\n * This function is extracted so that we can use it in both places without duplicating the logic.\n * Unfortunately \"just\" changing RegExp is too complicated now and making it pass all tests\n * and fix this case seems like an impossible, or at least way too time-consuming task.\n */\nconst extractSafariExtensionDetails = (func, filename) => {\n  const isSafariExtension = func.indexOf('safari-extension') !== -1;\n  const isSafariWebExtension = func.indexOf('safari-web-extension') !== -1;\n\n  return isSafariExtension || isSafariWebExtension\n    ? [\n        func.indexOf('@') !== -1 ? func.split('@')[0] : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`,\n      ]\n    : [func, filename];\n};\n\nexport { chromeStackLineParser, defaultStackLineParsers, defaultStackParser, geckoStackLineParser, opera10StackLineParser, opera11StackLineParser, winjsStackLineParser };\n//# sourceMappingURL=stack-parsers.js.map\n","import { fill, getFunctionName, getOriginalFunction } from '@sentry/utils';\nimport { WINDOW, wrap } from '../helpers.js';\n\nconst DEFAULT_EVENT_TARGET = [\n  'EventTarget',\n  'Window',\n  'Node',\n  'ApplicationCache',\n  'AudioTrackList',\n  'ChannelMergerNode',\n  'CryptoOperation',\n  'EventSource',\n  'FileReader',\n  'HTMLUnknownElement',\n  'IDBDatabase',\n  'IDBRequest',\n  'IDBTransaction',\n  'KeyOperation',\n  'MediaController',\n  'MessagePort',\n  'ModalWindow',\n  'Notification',\n  'SVGElementInstance',\n  'Screen',\n  'TextTrack',\n  'TextTrackCue',\n  'TextTrackList',\n  'WebSocket',\n  'WebSocketWorker',\n  'Worker',\n  'XMLHttpRequest',\n  'XMLHttpRequestEventTarget',\n  'XMLHttpRequestUpload',\n];\n\n/** Wrap timer functions and event targets to catch errors and provide better meta data */\nclass TryCatch  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'TryCatch';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = TryCatch.id;}\n\n  /** JSDoc */\n\n  /**\n   * @inheritDoc\n   */\n   constructor(options) {;TryCatch.prototype.__init.call(this);\n    this._options = {\n      XMLHttpRequest: true,\n      eventTarget: true,\n      requestAnimationFrame: true,\n      setInterval: true,\n      setTimeout: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Wrap timer functions and event targets to catch errors\n   * and provide better metadata.\n   */\n   setupOnce() {\n    if (this._options.setTimeout) {\n      fill(WINDOW, 'setTimeout', _wrapTimeFunction);\n    }\n\n    if (this._options.setInterval) {\n      fill(WINDOW, 'setInterval', _wrapTimeFunction);\n    }\n\n    if (this._options.requestAnimationFrame) {\n      fill(WINDOW, 'requestAnimationFrame', _wrapRAF);\n    }\n\n    if (this._options.XMLHttpRequest && 'XMLHttpRequest' in WINDOW) {\n      fill(XMLHttpRequest.prototype, 'send', _wrapXHR);\n    }\n\n    const eventTargetOption = this._options.eventTarget;\n    if (eventTargetOption) {\n      const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;\n      eventTarget.forEach(_wrapEventTarget);\n    }\n  }\n} TryCatch.__initStatic();\n\n/** JSDoc */\nfunction _wrapTimeFunction(original) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function ( ...args) {\n    const originalCallback = args[0];\n    args[0] = wrap(originalCallback, {\n      mechanism: {\n        data: { function: getFunctionName(original) },\n        handled: true,\n        type: 'instrument',\n      },\n    });\n    return original.apply(this, args);\n  };\n}\n\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _wrapRAF(original) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function ( callback) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return original.apply(this, [\n      wrap(callback, {\n        mechanism: {\n          data: {\n            function: 'requestAnimationFrame',\n            handler: getFunctionName(original),\n          },\n          handled: true,\n          type: 'instrument',\n        },\n      }),\n    ]);\n  };\n}\n\n/** JSDoc */\nfunction _wrapXHR(originalSend) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function ( ...args) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const xhr = this;\n    const xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];\n\n    xmlHttpRequestProps.forEach(prop => {\n      if (prop in xhr && typeof xhr[prop] === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        fill(xhr, prop, function (original) {\n          const wrapOptions = {\n            mechanism: {\n              data: {\n                function: prop,\n                handler: getFunctionName(original),\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          };\n\n          // If Instrument integration has been called before TryCatch, get the name of original function\n          const originalFunction = getOriginalFunction(original);\n          if (originalFunction) {\n            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);\n          }\n\n          // Otherwise wrap directly\n          return wrap(original, wrapOptions);\n        });\n      }\n    });\n\n    return originalSend.apply(this, args);\n  };\n}\n\n/** JSDoc */\nfunction _wrapEventTarget(target) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const globalObject = WINDOW ;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  const proto = globalObject[target] && globalObject[target].prototype;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n    return;\n  }\n\n  fill(proto, 'addEventListener', function (original)\n\n {\n    return function (\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      eventName,\n      fn,\n      options,\n    ) {\n      try {\n        if (typeof fn.handleEvent === 'function') {\n          // ESlint disable explanation:\n          //  First, it is generally safe to call `wrap` with an unbound function. Furthermore, using `.bind()` would\n          //  introduce a bug here, because bind returns a new function that doesn't have our\n          //  flags(like __sentry_original__) attached. `wrap` checks for those flags to avoid unnecessary wrapping.\n          //  Without those flags, every call to addEventListener wraps the function again, causing a memory leak.\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          fn.handleEvent = wrap(fn.handleEvent, {\n            mechanism: {\n              data: {\n                function: 'handleEvent',\n                handler: getFunctionName(fn),\n                target,\n              },\n              handled: true,\n              type: 'instrument',\n            },\n          });\n        }\n      } catch (err) {\n        // can sometimes get 'Permission denied to access property \"handle Event'\n      }\n\n      return original.apply(this, [\n        eventName,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        wrap(fn , {\n          mechanism: {\n            data: {\n              function: 'addEventListener',\n              handler: getFunctionName(fn),\n              target,\n            },\n            handled: true,\n            type: 'instrument',\n          },\n        }),\n        options,\n      ]);\n    };\n  });\n\n  fill(\n    proto,\n    'removeEventListener',\n    function (\n      originalRemoveEventListener,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n      return function (\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        eventName,\n        fn,\n        options,\n      ) {\n        /**\n         * There are 2 possible scenarios here:\n         *\n         * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified\n         * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function\n         * as a pass-through, and call original `removeEventListener` with it.\n         *\n         * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using\n         * our wrapped version of `addEventListener`, which internally calls `wrap` helper.\n         * This helper \"wraps\" whole callback inside a try/catch statement, and attached appropriate metadata to it,\n         * in order for us to make a distinction between wrapped/non-wrapped functions possible.\n         * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.\n         *\n         * When someone adds a handler prior to initialization, and then do it again, but after,\n         * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible\n         * to get rid of the initial handler and it'd stick there forever.\n         */\n        const wrappedEventHandler = fn ;\n        try {\n          const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;\n          if (originalEventHandler) {\n            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);\n          }\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);\n      };\n    },\n  );\n}\n\nexport { TryCatch };\n//# sourceMappingURL=trycatch.js.map\n","import { getCurrentHub } from '@sentry/core';\nimport { addInstrumentationHandler, isString, isPrimitive, isErrorEvent, getLocationHref, logger, addExceptionMechanism } from '@sentry/utils';\nimport { eventFromUnknownInput } from '../eventbuilder.js';\nimport { shouldIgnoreOnError } from '../helpers.js';\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/** Global handlers */\nclass GlobalHandlers  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'GlobalHandlers';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = GlobalHandlers.id;}\n\n  /** JSDoc */\n\n  /**\n   * Stores references functions to installing handlers. Will set to undefined\n   * after they have been run so that they are not used twice.\n   */\n   __init2() {this._installFunc = {\n    onerror: _installGlobalOnErrorHandler,\n    onunhandledrejection: _installGlobalOnUnhandledRejectionHandler,\n  };}\n\n  /** JSDoc */\n   constructor(options) {;GlobalHandlers.prototype.__init.call(this);GlobalHandlers.prototype.__init2.call(this);\n    this._options = {\n      onerror: true,\n      onunhandledrejection: true,\n      ...options,\n    };\n  }\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    Error.stackTraceLimit = 50;\n    const options = this._options;\n\n    // We can disable guard-for-in as we construct the options object above + do checks against\n    // `this._installFunc` for the property.\n    // eslint-disable-next-line guard-for-in\n    for (const key in options) {\n      const installFunc = this._installFunc[key ];\n      if (installFunc && options[key ]) {\n        globalHandlerLog(key);\n        installFunc();\n        this._installFunc[key ] = undefined;\n      }\n    }\n  }\n} GlobalHandlers.__initStatic();\n\n/** JSDoc */\nfunction _installGlobalOnErrorHandler() {\n  addInstrumentationHandler(\n    'error',\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (data) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      const { msg, url, line, column, error } = data;\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return;\n      }\n\n      const event =\n        error === undefined && isString(msg)\n          ? _eventFromIncompleteOnError(msg, url, line, column)\n          : _enhanceEventWithInitialFrame(\n              eventFromUnknownInput(stackParser, error || msg, undefined, attachStacktrace, false),\n              url,\n              line,\n              column,\n            );\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onerror');\n    },\n  );\n}\n\n/** JSDoc */\nfunction _installGlobalOnUnhandledRejectionHandler() {\n  addInstrumentationHandler(\n    'unhandledrejection',\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (e) => {\n      const [hub, stackParser, attachStacktrace] = getHubAndOptions();\n      if (!hub.getIntegration(GlobalHandlers)) {\n        return;\n      }\n      let error = e;\n\n      // dig the object of the rejection out of known event types\n      try {\n        // PromiseRejectionEvents store the object of the rejection under 'reason'\n        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent\n        if ('reason' in e) {\n          error = e.reason;\n        }\n        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents\n        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into\n        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec\n        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and\n        // https://github.com/getsentry/sentry-javascript/issues/2380\n        else if ('detail' in e && 'reason' in e.detail) {\n          error = e.detail.reason;\n        }\n      } catch (_oO) {\n        // no-empty\n      }\n\n      if (shouldIgnoreOnError() || (error && error.__sentry_own_request__)) {\n        return true;\n      }\n\n      const event = isPrimitive(error)\n        ? _eventFromRejectionWithPrimitive(error)\n        : eventFromUnknownInput(stackParser, error, undefined, attachStacktrace, true);\n\n      event.level = 'error';\n\n      addMechanismAndCapture(hub, error, event, 'onunhandledrejection');\n      return;\n    },\n  );\n}\n\n/**\n * Create an event from a promise rejection where the `reason` is a primitive.\n *\n * @param reason: The `reason` property of the promise rejection\n * @returns An Event object with an appropriate `exception` value\n */\nfunction _eventFromRejectionWithPrimitive(reason) {\n  return {\n    exception: {\n      values: [\n        {\n          type: 'UnhandledRejection',\n          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)\n          value: `Non-Error promise rejection captured with value: ${String(reason)}`,\n        },\n      ],\n    },\n  };\n}\n\n/**\n * This function creates a stack from an old, error-less onerror handler.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _eventFromIncompleteOnError(msg, url, line, column) {\n  const ERROR_TYPES_RE =\n    /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;\n\n  // If 'message' is ErrorEvent, get real message from inside\n  let message = isErrorEvent(msg) ? msg.message : msg;\n  let name = 'Error';\n\n  const groups = message.match(ERROR_TYPES_RE);\n  if (groups) {\n    name = groups[1];\n    message = groups[2];\n  }\n\n  const event = {\n    exception: {\n      values: [\n        {\n          type: name,\n          value: message,\n        },\n      ],\n    },\n  };\n\n  return _enhanceEventWithInitialFrame(event, url, line, column);\n}\n\n/** JSDoc */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _enhanceEventWithInitialFrame(event, url, line, column) {\n  // event.exception\n  const e = (event.exception = event.exception || {});\n  // event.exception.values\n  const ev = (e.values = e.values || []);\n  // event.exception.values[0]\n  const ev0 = (ev[0] = ev[0] || {});\n  // event.exception.values[0].stacktrace\n  const ev0s = (ev0.stacktrace = ev0.stacktrace || {});\n  // event.exception.values[0].stacktrace.frames\n  const ev0sf = (ev0s.frames = ev0s.frames || []);\n\n  const colno = isNaN(parseInt(column, 10)) ? undefined : column;\n  const lineno = isNaN(parseInt(line, 10)) ? undefined : line;\n  const filename = isString(url) && url.length > 0 ? url : getLocationHref();\n\n  // event.exception.values[0].stacktrace.frames\n  if (ev0sf.length === 0) {\n    ev0sf.push({\n      colno,\n      filename,\n      function: '?',\n      in_app: true,\n      lineno,\n    });\n  }\n\n  return event;\n}\n\nfunction globalHandlerLog(type) {\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Global Handler attached: ${type}`);\n}\n\nfunction addMechanismAndCapture(hub, error, event, type) {\n  addExceptionMechanism(event, {\n    handled: false,\n    type,\n  });\n  hub.captureEvent(event, {\n    originalException: error,\n  });\n}\n\nfunction getHubAndOptions() {\n  const hub = getCurrentHub();\n  const client = hub.getClient();\n  const options = (client && client.getOptions()) || {\n    stackParser: () => [],\n    attachStacktrace: false,\n  };\n  return [hub, options.stackParser, options.attachStacktrace];\n}\n\nexport { GlobalHandlers };\n//# sourceMappingURL=globalhandlers.js.map\n","import { getCurrentHub, addGlobalEventProcessor } from '@sentry/core';\nimport { isInstanceOf } from '@sentry/utils';\nimport { exceptionFromError } from '../eventbuilder.js';\n\nconst DEFAULT_KEY = 'cause';\nconst DEFAULT_LIMIT = 5;\n\n/** Adds SDK info to an event. */\nclass LinkedErrors  {\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'LinkedErrors';}\n\n  /**\n   * @inheritDoc\n   */\n    __init() {this.name = LinkedErrors.id;}\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * @inheritDoc\n   */\n   constructor(options = {}) {;LinkedErrors.prototype.__init.call(this);\n    this._key = options.key || DEFAULT_KEY;\n    this._limit = options.limit || DEFAULT_LIMIT;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    const client = getCurrentHub().getClient();\n    if (!client) {\n      return;\n    }\n    addGlobalEventProcessor((event, hint) => {\n      const self = getCurrentHub().getIntegration(LinkedErrors);\n      return self ? _handler(client.getOptions().stackParser, self._key, self._limit, event, hint) : event;\n    });\n  }\n} LinkedErrors.__initStatic();\n\n/**\n * @inheritDoc\n */\nfunction _handler(\n  parser,\n  key,\n  limit,\n  event,\n  hint,\n) {\n  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {\n    return event;\n  }\n  const linkedErrors = _walkErrorTree(parser, limit, hint.originalException , key);\n  event.exception.values = [...linkedErrors, ...event.exception.values];\n  return event;\n}\n\n/**\n * JSDOC\n */\nfunction _walkErrorTree(\n  parser,\n  limit,\n  error,\n  key,\n  stack = [],\n) {\n  if (!isInstanceOf(error[key], Error) || stack.length + 1 >= limit) {\n    return stack;\n  }\n  const exception = exceptionFromError(parser, error[key]);\n  return _walkErrorTree(parser, limit, error[key], key, [exception, ...stack]);\n}\n\nexport { LinkedErrors, _handler, _walkErrorTree };\n//# sourceMappingURL=linkederrors.js.map\n","import { logger } from '@sentry/utils';\n\n/** Deduplication filter */\nclass Dedupe  {constructor() { Dedupe.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'Dedupe';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = Dedupe.id;}\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(addGlobalEventProcessor, getCurrentHub) {\n    const eventProcessor = currentEvent => {\n      const self = getCurrentHub().getIntegration(Dedupe);\n      if (self) {\n        // Juuust in case something goes wrong\n        try {\n          if (_shouldDropEvent(currentEvent, self._previousEvent)) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Event dropped due to being a duplicate of previously captured event.');\n            return null;\n          }\n        } catch (_oO) {\n          return (self._previousEvent = currentEvent);\n        }\n\n        return (self._previousEvent = currentEvent);\n      }\n      return currentEvent;\n    };\n\n    eventProcessor.id = this.name;\n    addGlobalEventProcessor(eventProcessor);\n  }\n} Dedupe.__initStatic();\n\n/** JSDoc */\nfunction _shouldDropEvent(currentEvent, previousEvent) {\n  if (!previousEvent) {\n    return false;\n  }\n\n  if (_isSameMessageEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  if (_isSameExceptionEvent(currentEvent, previousEvent)) {\n    return true;\n  }\n\n  return false;\n}\n\n/** JSDoc */\nfunction _isSameMessageEvent(currentEvent, previousEvent) {\n  const currentMessage = currentEvent.message;\n  const previousMessage = previousEvent.message;\n\n  // If neither event has a message property, they were both exceptions, so bail out\n  if (!currentMessage && !previousMessage) {\n    return false;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentMessage && !previousMessage) || (!currentMessage && previousMessage)) {\n    return false;\n  }\n\n  if (currentMessage !== previousMessage) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameExceptionEvent(currentEvent, previousEvent) {\n  const previousException = _getExceptionFromEvent(previousEvent);\n  const currentException = _getExceptionFromEvent(currentEvent);\n\n  if (!previousException || !currentException) {\n    return false;\n  }\n\n  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {\n    return false;\n  }\n\n  if (!_isSameFingerprint(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  if (!_isSameStacktrace(currentEvent, previousEvent)) {\n    return false;\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameStacktrace(currentEvent, previousEvent) {\n  let currentFrames = _getFramesFromEvent(currentEvent);\n  let previousFrames = _getFramesFromEvent(previousEvent);\n\n  // If neither event has a stacktrace, they are assumed to be the same\n  if (!currentFrames && !previousFrames) {\n    return true;\n  }\n\n  // If only one event has a stacktrace, but not the other one, they are not the same\n  if ((currentFrames && !previousFrames) || (!currentFrames && previousFrames)) {\n    return false;\n  }\n\n  currentFrames = currentFrames ;\n  previousFrames = previousFrames ;\n\n  // If number of frames differ, they are not the same\n  if (previousFrames.length !== currentFrames.length) {\n    return false;\n  }\n\n  // Otherwise, compare the two\n  for (let i = 0; i < previousFrames.length; i++) {\n    const frameA = previousFrames[i];\n    const frameB = currentFrames[i];\n\n    if (\n      frameA.filename !== frameB.filename ||\n      frameA.lineno !== frameB.lineno ||\n      frameA.colno !== frameB.colno ||\n      frameA.function !== frameB.function\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/** JSDoc */\nfunction _isSameFingerprint(currentEvent, previousEvent) {\n  let currentFingerprint = currentEvent.fingerprint;\n  let previousFingerprint = previousEvent.fingerprint;\n\n  // If neither event has a fingerprint, they are assumed to be the same\n  if (!currentFingerprint && !previousFingerprint) {\n    return true;\n  }\n\n  // If only one event has a fingerprint, but not the other one, they are not the same\n  if ((currentFingerprint && !previousFingerprint) || (!currentFingerprint && previousFingerprint)) {\n    return false;\n  }\n\n  currentFingerprint = currentFingerprint ;\n  previousFingerprint = previousFingerprint ;\n\n  // Otherwise, compare the two\n  try {\n    return !!(currentFingerprint.join('') === previousFingerprint.join(''));\n  } catch (_oO) {\n    return false;\n  }\n}\n\n/** JSDoc */\nfunction _getExceptionFromEvent(event) {\n  return event.exception && event.exception.values && event.exception.values[0];\n}\n\n/** JSDoc */\nfunction _getFramesFromEvent(event) {\n  const exception = event.exception;\n\n  if (exception) {\n    try {\n      // @ts-ignore Object could be undefined\n      return exception.values[0].stacktrace.frames;\n    } catch (_oO) {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\nexport { Dedupe };\n//# sourceMappingURL=dedupe.js.map\n","import { addGlobalEventProcessor, getCurrentHub } from '@sentry/core';\nimport { WINDOW } from '../helpers.js';\n\n/** HttpContext integration collects information about HTTP request headers */\nclass HttpContext  {constructor() { HttpContext.prototype.__init.call(this); }\n  /**\n   * @inheritDoc\n   */\n   static __initStatic() {this.id = 'HttpContext';}\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = HttpContext.id;}\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce() {\n    addGlobalEventProcessor((event) => {\n      if (getCurrentHub().getIntegration(HttpContext)) {\n        // if none of the information we want exists, don't bother\n        if (!WINDOW.navigator && !WINDOW.location && !WINDOW.document) {\n          return event;\n        }\n\n        // grab as much info as exists and add it to the event\n        const url = (event.request && event.request.url) || (WINDOW.location && WINDOW.location.href);\n        const { referrer } = WINDOW.document || {};\n        const { userAgent } = WINDOW.navigator || {};\n\n        const headers = {\n          ...(event.request && event.request.headers),\n          ...(referrer && { Referer: referrer }),\n          ...(userAgent && { 'User-Agent': userAgent }),\n        };\n        const request = { ...(url && { url }), headers };\n\n        return { ...event, request };\n      }\n      return event;\n    });\n  }\n} HttpContext.__initStatic();\n\nexport { HttpContext };\n//# sourceMappingURL=httpcontext.js.map\n","import { SentryError } from './error.js';\nimport { rejectedSyncPromise, SyncPromise, resolvedSyncPromise } from './syncpromise.js';\n\n/**\n * Creates an new PromiseBuffer object with the specified limit\n * @param limit max number of promises that can be stored in the buffer\n */\nfunction makePromiseBuffer(limit) {\n  const buffer = [];\n\n  function isReady() {\n    return limit === undefined || buffer.length < limit;\n  }\n\n  /**\n   * Remove a promise from the queue.\n   *\n   * @param task Can be any PromiseLike<T>\n   * @returns Removed promise.\n   */\n  function remove(task) {\n    return buffer.splice(buffer.indexOf(task), 1)[0];\n  }\n\n  /**\n   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n   *\n   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n   *        limit check.\n   * @returns The original promise.\n   */\n  function add(taskProducer) {\n    if (!isReady()) {\n      return rejectedSyncPromise(new SentryError('Not adding Promise because buffer limit was reached.'));\n    }\n\n    // start the task and add its promise to the queue\n    const task = taskProducer();\n    if (buffer.indexOf(task) === -1) {\n      buffer.push(task);\n    }\n    void task\n      .then(() => remove(task))\n      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n      // have promises, so TS has to polyfill when down-compiling.)\n      .then(null, () =>\n        remove(task).then(null, () => {\n          // We have to add another catch here because `remove()` starts a new promise chain.\n        }),\n      );\n    return task;\n  }\n\n  /**\n   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n   * `false` otherwise\n   */\n  function drain(timeout) {\n    return new SyncPromise((resolve, reject) => {\n      let counter = buffer.length;\n\n      if (!counter) {\n        return resolve(true);\n      }\n\n      // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n      const capturedSetTimeout = setTimeout(() => {\n        if (timeout && timeout > 0) {\n          resolve(false);\n        }\n      }, timeout);\n\n      // if all promises resolve in time, cancel the timer and resolve to `true`\n      buffer.forEach(item => {\n        void resolvedSyncPromise(item).then(() => {\n          if (!--counter) {\n            clearTimeout(capturedSetTimeout);\n            resolve(true);\n          }\n        }, reject);\n      });\n    });\n  }\n\n  return {\n    $: buffer,\n    add,\n    drain,\n  };\n}\n\nexport { makePromiseBuffer };\n//# sourceMappingURL=promisebuffer.js.map\n","// Intentionally keeping the key broad, as we don't know for sure what rate limit headers get returned from backend\n\nconst DEFAULT_RETRY_AFTER = 60 * 1000; // 60 seconds\n\n/**\n * Extracts Retry-After value from the request header or returns default value\n * @param header string representation of 'Retry-After' header\n * @param now current unix timestamp\n *\n */\nfunction parseRetryAfterHeader(header, now = Date.now()) {\n  const headerDelay = parseInt(`${header}`, 10);\n  if (!isNaN(headerDelay)) {\n    return headerDelay * 1000;\n  }\n\n  const headerDate = Date.parse(`${header}`);\n  if (!isNaN(headerDate)) {\n    return headerDate - now;\n  }\n\n  return DEFAULT_RETRY_AFTER;\n}\n\n/**\n * Gets the time that given category is disabled until for rate limiting\n */\nfunction disabledUntil(limits, category) {\n  return limits[category] || limits.all || 0;\n}\n\n/**\n * Checks if a category is rate limited\n */\nfunction isRateLimited(limits, category, now = Date.now()) {\n  return disabledUntil(limits, category) > now;\n}\n\n/**\n * Update ratelimits from incoming headers.\n * Returns true if headers contains a non-empty rate limiting header.\n */\nfunction updateRateLimits(\n  limits,\n  { statusCode, headers },\n  now = Date.now(),\n) {\n  const updatedRateLimits = {\n    ...limits,\n  };\n\n  // \"The name is case-insensitive.\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n  const rateLimitHeader = headers && headers['x-sentry-rate-limits'];\n  const retryAfterHeader = headers && headers['retry-after'];\n\n  if (rateLimitHeader) {\n    /**\n     * rate limit headers are of the form\n     *     <header>,<header>,..\n     * where each <header> is of the form\n     *     <retry_after>: <categories>: <scope>: <reason_code>\n     * where\n     *     <retry_after> is a delay in seconds\n     *     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n     *         <category>;<category>;...\n     *     <scope> is what's being limited (org, project, or key) - ignored by SDK\n     *     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n     */\n    for (const limit of rateLimitHeader.trim().split(',')) {\n      const [retryAfter, categories] = limit.split(':', 2);\n      const headerDelay = parseInt(retryAfter, 10);\n      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n      if (!categories) {\n        updatedRateLimits.all = now + delay;\n      } else {\n        for (const category of categories.split(';')) {\n          updatedRateLimits[category] = now + delay;\n        }\n      }\n    }\n  } else if (retryAfterHeader) {\n    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);\n  } else if (statusCode === 429) {\n    updatedRateLimits.all = now + 60 * 1000;\n  }\n\n  return updatedRateLimits;\n}\n\nexport { DEFAULT_RETRY_AFTER, disabledUntil, isRateLimited, parseRetryAfterHeader, updateRateLimits };\n//# sourceMappingURL=ratelimit.js.map\n","import { forEachEnvelopeItem, envelopeItemTypeToDataCategory, isRateLimited, resolvedSyncPromise, createEnvelope, serializeEnvelope, logger, updateRateLimits, SentryError, makePromiseBuffer } from '@sentry/utils';\n\nconst DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nfunction createTransport(\n  options,\n  makeRequest,\n  buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n) {\n  let rateLimits = {};\n\n  const flush = (timeout) => buffer.drain(timeout);\n\n  function send(envelope) {\n    const filteredEnvelopeItems = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      const envelopeItemDataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, envelopeItemDataCategory)) {\n        const event = getEventForEnvelopeItem(item, type);\n        options.recordDroppedEvent('ratelimit_backoff', envelopeItemDataCategory, event);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return resolvedSyncPromise();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems );\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = (reason) => {\n      forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n        const event = getEventForEnvelopeItem(item, type);\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);\n      });\n    };\n\n    const requestTask = () =>\n      makeRequest({ body: serializeEnvelope(filteredEnvelope, options.textEncoder) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = updateRateLimits(rateLimits, response);\n        },\n        error => {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Failed while sending event:', error);\n          recordEnvelopeLoss('network_error');\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error instanceof SentryError) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return resolvedSyncPromise();\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nfunction getEventForEnvelopeItem(item, type) {\n  if (type !== 'event' && type !== 'transaction') {\n    return undefined;\n  }\n\n  return Array.isArray(item) ? (item )[1] : undefined;\n}\n\nexport { DEFAULT_TRANSPORT_BUFFER_SIZE, createTransport };\n//# sourceMappingURL=base.js.map\n","import { isNativeFetch, logger } from '@sentry/utils';\nimport { WINDOW } from '../helpers.js';\n\nlet cachedFetchImpl = undefined;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction getNativeFetchImplementation() {\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n\n  /* eslint-disable @typescript-eslint/unbound-method */\n\n  // Fast path to avoid DOM I/O\n  if (isNativeFetch(WINDOW.fetch)) {\n    return (cachedFetchImpl = WINDOW.fetch.bind(WINDOW));\n  }\n\n  const document = WINDOW.document;\n  let fetchImpl = WINDOW.fetch;\n  // eslint-disable-next-line deprecation/deprecation\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.fetch) {\n        fetchImpl = contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return (cachedFetchImpl = fetchImpl.bind(WINDOW));\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n\n/** Clears cached fetch impl */\nfunction clearCachedFetchImplementation() {\n  cachedFetchImpl = undefined;\n}\n\nexport { clearCachedFetchImplementation, getNativeFetchImplementation };\n//# sourceMappingURL=utils.js.map\n","import { createTransport } from '@sentry/core';\nimport { rejectedSyncPromise } from '@sentry/utils';\nimport { clearCachedFetchImplementation, getNativeFetchImplementation } from './utils.js';\n\n/**\n * Creates a Transport that uses the Fetch API to send events to Sentry.\n */\nfunction makeFetchTransport(\n  options,\n  nativeFetch = getNativeFetchImplementation(),\n) {\n  function makeRequest(request) {\n    const requestOptions = {\n      body: request.body,\n      method: 'POST',\n      referrerPolicy: 'origin',\n      headers: options.headers,\n      // Outgoing requests are usually cancelled when navigating to a different page, causing a \"TypeError: Failed to\n      // fetch\" error and sending a \"network_error\" client-outcome - in Chrome, the request status shows \"(cancelled)\".\n      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're\n      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).\n      // Gotchas:\n      // - `keepalive` isn't supported by Firefox\n      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch), a request with `keepalive: true`\n      //   and a content length of > 64 kibibytes returns a network error. We will therefore only activate the flag when\n      //   we're below that limit.\n      keepalive: request.body.length <= 65536,\n      ...options.fetchOptions,\n    };\n\n    try {\n      return nativeFetch(options.url, requestOptions).then(response => ({\n        statusCode: response.status,\n        headers: {\n          'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n          'retry-after': response.headers.get('Retry-After'),\n        },\n      }));\n    } catch (e) {\n      clearCachedFetchImplementation();\n      return rejectedSyncPromise(e);\n    }\n  }\n\n  return createTransport(options, makeRequest);\n}\n\nexport { makeFetchTransport };\n//# sourceMappingURL=fetch.js.map\n","import { createTransport } from '@sentry/core';\nimport { SyncPromise } from '@sentry/utils';\n\n/**\n * The DONE ready state for XmlHttpRequest\n *\n * Defining it here as a constant b/c XMLHttpRequest.DONE is not always defined\n * (e.g. during testing, it is `undefined`)\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState}\n */\nconst XHR_READYSTATE_DONE = 4;\n\n/**\n * Creates a Transport that uses the XMLHttpRequest API to send events to Sentry.\n */\nfunction makeXHRTransport(options) {\n  function makeRequest(request) {\n    return new SyncPromise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n\n      xhr.onerror = reject;\n\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === XHR_READYSTATE_DONE) {\n          resolve({\n            statusCode: xhr.status,\n            headers: {\n              'x-sentry-rate-limits': xhr.getResponseHeader('X-Sentry-Rate-Limits'),\n              'retry-after': xhr.getResponseHeader('Retry-After'),\n            },\n          });\n        }\n      };\n\n      xhr.open('POST', options.url);\n\n      for (const header in options.headers) {\n        if (Object.prototype.hasOwnProperty.call(options.headers, header)) {\n          xhr.setRequestHeader(header, options.headers[header]);\n        }\n      }\n\n      xhr.send(request.body);\n    });\n  }\n\n  return createTransport(options, makeRequest);\n}\n\nexport { makeXHRTransport };\n//# sourceMappingURL=xhr.js.map\n","import { Integrations, getIntegrationsToSetup, initAndBind, getReportDialogEndpoint, getCurrentHub } from '@sentry/core';\nimport { stackParserFromStackParserOptions, supportsFetch, logger, resolvedSyncPromise, addInstrumentationHandler } from '@sentry/utils';\nimport { BrowserClient } from './client.js';\nimport { WINDOW, wrap as wrap$1 } from './helpers.js';\nimport './integrations/index.js';\nimport { defaultStackParser } from './stack-parsers.js';\nimport './transports/index.js';\nimport { TryCatch } from './integrations/trycatch.js';\nimport { Breadcrumbs } from './integrations/breadcrumbs.js';\nimport { GlobalHandlers } from './integrations/globalhandlers.js';\nimport { LinkedErrors } from './integrations/linkederrors.js';\nimport { Dedupe } from './integrations/dedupe.js';\nimport { HttpContext } from './integrations/httpcontext.js';\nimport { makeFetchTransport } from './transports/fetch.js';\nimport { makeXHRTransport } from './transports/xhr.js';\n\nconst defaultIntegrations = [\n  new Integrations.InboundFilters(),\n  new Integrations.FunctionToString(),\n  new TryCatch(),\n  new Breadcrumbs(),\n  new GlobalHandlers(),\n  new LinkedErrors(),\n  new Dedupe(),\n  new HttpContext(),\n];\n\n/**\n * A magic string that build tooling can leverage in order to inject a release value into the SDK.\n */\n\n/**\n * The Sentry Browser SDK Client.\n *\n * To use this SDK, call the {@link init} function as early as possible when\n * loading the web page. To set context information or send manual events, use\n * the provided methods.\n *\n * @example\n *\n * ```\n *\n * import { init } from '@sentry/browser';\n *\n * init({\n *   dsn: '__DSN__',\n *   // ...\n * });\n * ```\n *\n * @example\n * ```\n *\n * import { configureScope } from '@sentry/browser';\n * configureScope((scope: Scope) => {\n *   scope.setExtra({ battery: 0.7 });\n *   scope.setTag({ user_mode: 'admin' });\n *   scope.setUser({ id: '4711' });\n * });\n * ```\n *\n * @example\n * ```\n *\n * import { addBreadcrumb } from '@sentry/browser';\n * addBreadcrumb({\n *   message: 'My Breadcrumb',\n *   // ...\n * });\n * ```\n *\n * @example\n *\n * ```\n *\n * import * as Sentry from '@sentry/browser';\n * Sentry.captureMessage('Hello, world!');\n * Sentry.captureException(new Error('Good bye'));\n * Sentry.captureEvent({\n *   message: 'Manual',\n *   stacktrace: [\n *     // ...\n *   ],\n * });\n * ```\n *\n * @see {@link BrowserOptions} for documentation on configuration options.\n */\nfunction init(options = {}) {\n  if (options.defaultIntegrations === undefined) {\n    options.defaultIntegrations = defaultIntegrations;\n  }\n  if (options.release === undefined) {\n    // This allows build tooling to find-and-replace __SENTRY_RELEASE__ to inject a release value\n    if (typeof __SENTRY_RELEASE__ === 'string') {\n      options.release = __SENTRY_RELEASE__;\n    }\n\n    // This supports the variable that sentry-webpack-plugin injects\n    if (WINDOW.SENTRY_RELEASE && WINDOW.SENTRY_RELEASE.id) {\n      options.release = WINDOW.SENTRY_RELEASE.id;\n    }\n  }\n  if (options.autoSessionTracking === undefined) {\n    options.autoSessionTracking = true;\n  }\n  if (options.sendClientReports === undefined) {\n    options.sendClientReports = true;\n  }\n\n  const clientOptions = {\n    ...options,\n    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),\n    integrations: getIntegrationsToSetup(options),\n    transport: options.transport || (supportsFetch() ? makeFetchTransport : makeXHRTransport),\n  };\n\n  initAndBind(BrowserClient, clientOptions);\n\n  if (options.autoSessionTracking) {\n    startSessionTracking();\n  }\n}\n\n/**\n * Present the user with a report dialog.\n *\n * @param options Everything is optional, we try to fetch all info need from the global scope.\n */\nfunction showReportDialog(options = {}, hub = getCurrentHub()) {\n  // doesn't work without a document (React Native)\n  if (!WINDOW.document) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Global document not defined in showReportDialog call');\n    return;\n  }\n\n  const { client, scope } = hub.getStackTop();\n  const dsn = options.dsn || (client && client.getDsn());\n  if (!dsn) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('DSN not configured for showReportDialog call');\n    return;\n  }\n\n  if (scope) {\n    options.user = {\n      ...scope.getUser(),\n      ...options.user,\n    };\n  }\n\n  if (!options.eventId) {\n    options.eventId = hub.lastEventId();\n  }\n\n  const script = WINDOW.document.createElement('script');\n  script.async = true;\n  script.src = getReportDialogEndpoint(dsn, options);\n\n  if (options.onLoad) {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    script.onload = options.onLoad;\n  }\n\n  const injectionPoint = WINDOW.document.head || WINDOW.document.body;\n  if (injectionPoint) {\n    injectionPoint.appendChild(script);\n  } else {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Not injecting report dialog. No injection point found in HTML');\n  }\n}\n\n/**\n * This is the getter for lastEventId.\n *\n * @returns The last event id of a captured event.\n */\nfunction lastEventId() {\n  return getCurrentHub().lastEventId();\n}\n\n/**\n * This function is here to be API compatible with the loader.\n * @hidden\n */\nfunction forceLoad() {\n  // Noop\n}\n\n/**\n * This function is here to be API compatible with the loader.\n * @hidden\n */\nfunction onLoad(callback) {\n  callback();\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nfunction flush(timeout) {\n  const client = getCurrentHub().getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot flush events. No client defined.');\n  return resolvedSyncPromise(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nfunction close(timeout) {\n  const client = getCurrentHub().getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Cannot flush events and disable SDK. No client defined.');\n  return resolvedSyncPromise(false);\n}\n\n/**\n * Wrap code within a try/catch block so the SDK is able to capture errors.\n *\n * @param fn A function to wrap.\n *\n * @returns The result of wrapped function call.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction wrap(fn) {\n  return wrap$1(fn)();\n}\n\nfunction startSessionOnHub(hub) {\n  hub.startSession({ ignoreDuration: true });\n  hub.captureSession();\n}\n\n/**\n * Enable automatic Session Tracking for the initial page load.\n */\nfunction startSessionTracking() {\n  if (typeof WINDOW.document === 'undefined') {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn('Session tracking in non-browser environment with @sentry/browser is not supported.');\n    return;\n  }\n\n  const hub = getCurrentHub();\n\n  // The only way for this to be false is for there to be a version mismatch between @sentry/browser (>= 6.0.0) and\n  // @sentry/hub (< 5.27.0). In the simple case, there won't ever be such a mismatch, because the two packages are\n  // pinned at the same version in package.json, but there are edge cases where it's possible. See\n  // https://github.com/getsentry/sentry-javascript/issues/3207 and\n  // https://github.com/getsentry/sentry-javascript/issues/3234 and\n  // https://github.com/getsentry/sentry-javascript/issues/3278.\n  if (!hub.captureSession) {\n    return;\n  }\n\n  // The session duration for browser sessions does not track a meaningful\n  // concept that can be used as a metric.\n  // Automatically captured sessions are akin to page views, and thus we\n  // discard their duration.\n  startSessionOnHub(hub);\n\n  // We want to create a session for every navigation as well\n  addInstrumentationHandler('history', ({ from, to }) => {\n    // Don't create an additional session for the initial route or if the location did not change\n    if (!(from === undefined || from === to)) {\n      startSessionOnHub(getCurrentHub());\n    }\n  });\n}\n\nexport { close, defaultIntegrations, flush, forceLoad, init, lastEventId, onLoad, showReportDialog, wrap };\n//# sourceMappingURL=sdk.js.map\n","import { SDK_VERSION, init as init$1 } from '@sentry/browser';\n\n/**\n * Inits the React SDK\n */\nfunction init(options) {\n  options._metadata = options._metadata || {};\n  options._metadata.sdk = options._metadata.sdk || {\n    name: 'sentry.javascript.react',\n    packages: [\n      {\n        name: 'npm:@sentry/react',\n        version: SDK_VERSION,\n      },\n    ],\n    version: SDK_VERSION,\n  };\n  init$1(options);\n}\n\nexport { init };\n//# sourceMappingURL=sdk.js.map\n","import { getMainCarrier } from '@sentry/core';\nimport { logger, isNaN, dynamicRequire, loadModule, isNodeEnv } from '@sentry/utils';\nimport { registerErrorInstrumentation } from './errors.js';\nimport { IdleTransaction } from './idletransaction.js';\nimport { Transaction } from './transaction.js';\nimport { hasTracingEnabled } from './utils.js';\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders() {\n  const scope = this.getScope();\n  if (scope) {\n    const span = scope.getSpan();\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent(),\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * Makes a sampling decision for the given transaction and stores it on the transaction.\n *\n * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be\n * sent to Sentry.\n *\n * @param transaction: The transaction needing a sampling decision\n * @param options: The current client's options, so we can access `tracesSampleRate` and/or `tracesSampler`\n * @param samplingContext: Default and user-provided data which may be used to help make the decision\n *\n * @returns The given transaction with its `sampled` value set\n */\nfunction sample(\n  transaction,\n  options,\n  samplingContext,\n) {\n  // nothing to do if tracing is not enabled\n  if (!hasTracingEnabled(options)) {\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that\n  if (transaction.sampled !== undefined) {\n    transaction.setMetadata({\n      sampleRate: Number(transaction.sampled),\n    });\n    return transaction;\n  }\n\n  // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should\n  // work; prefer the hook if so\n  let sampleRate;\n  if (typeof options.tracesSampler === 'function') {\n    sampleRate = options.tracesSampler(samplingContext);\n    transaction.setMetadata({\n      sampleRate: Number(sampleRate),\n    });\n  } else if (samplingContext.parentSampled !== undefined) {\n    sampleRate = samplingContext.parentSampled;\n  } else {\n    sampleRate = options.tracesSampleRate;\n    transaction.setMetadata({\n      sampleRate: Number(sampleRate),\n    });\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(sampleRate)) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('[Tracing] Discarding transaction because of invalid sample rate.');\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped\n  if (!sampleRate) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.log(\n        `[Tracing] Discarding transaction because ${\n          typeof options.tracesSampler === 'function'\n            ? 'tracesSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'\n        }`,\n      );\n    transaction.sampled = false;\n    return transaction;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  transaction.sampled = Math.random() < (sampleRate );\n\n  // if we're not going to keep it, we're done\n  if (!transaction.sampled) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.log(\n        `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(\n          sampleRate,\n        )})`,\n      );\n    return transaction;\n  }\n\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] starting ${transaction.op} transaction - ${transaction.name}`);\n  return transaction;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n */\nfunction isValidSampleRate(rate) {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if (isNaN(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(\n        `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn(`[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Creates a new transaction and adds a sampling decision if it doesn't yet have one.\n *\n * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if\n * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an\n * \"extension method.\"\n *\n * @param this: The Hub starting the transaction\n * @param transactionContext: Data used to configure the transaction\n * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)\n *\n * @returns The new transaction\n *\n * @see {@link Hub.startTransaction}\n */\nfunction _startTransaction(\n\n  transactionContext,\n  customSamplingContext,\n) {\n  const client = this.getClient();\n  const options = (client && client.getOptions()) || {};\n\n  const configInstrumenter = options.instrumenter || 'sentry';\n  const transactionInstrumenter = transactionContext.instrumenter || 'sentry';\n\n  if (configInstrumenter !== transactionInstrumenter) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.error(\n        `A transaction was started with instrumenter=\\`${transactionInstrumenter}\\`, but the SDK is configured with the \\`${configInstrumenter}\\` instrumenter.\nThe transaction will not be sampled. Please use the ${configInstrumenter} instrumentation to start transactions.`,\n      );\n\n    transactionContext.sampled = false;\n  }\n\n  let transaction = new Transaction(transactionContext, this);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));\n  }\n  return transaction;\n}\n\n/**\n * Create new idle transaction.\n */\nfunction startIdleTransaction(\n  hub,\n  transactionContext,\n  idleTimeout,\n  finalTimeout,\n  onScope,\n  customSamplingContext,\n  heartbeatInterval,\n) {\n  const client = hub.getClient();\n  const options = (client && client.getOptions()) || {};\n\n  let transaction = new IdleTransaction(transactionContext, hub, idleTimeout, finalTimeout, heartbeatInterval, onScope);\n  transaction = sample(transaction, options, {\n    parentSampled: transactionContext.parentSampled,\n    transactionContext,\n    ...customSamplingContext,\n  });\n  if (transaction.sampled) {\n    transaction.initSpanRecorder(options._experiments && (options._experiments.maxSpans ));\n  }\n  return transaction;\n}\n\n/**\n * @private\n */\nfunction _addTracingExtensions() {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n  carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n  if (!carrier.__SENTRY__.extensions.startTransaction) {\n    carrier.__SENTRY__.extensions.startTransaction = _startTransaction;\n  }\n  if (!carrier.__SENTRY__.extensions.traceHeaders) {\n    carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n  }\n}\n\n/**\n * @private\n */\nfunction _autoloadDatabaseIntegrations() {\n  const carrier = getMainCarrier();\n  if (!carrier.__SENTRY__) {\n    return;\n  }\n\n  const packageToIntegrationMapping = {\n    mongodb() {\n      const integration = dynamicRequire(module, './integrations/node/mongo')\n\n;\n      return new integration.Mongo();\n    },\n    mongoose() {\n      const integration = dynamicRequire(module, './integrations/node/mongo')\n\n;\n      return new integration.Mongo({ mongoose: true });\n    },\n    mysql() {\n      const integration = dynamicRequire(module, './integrations/node/mysql')\n\n;\n      return new integration.Mysql();\n    },\n    pg() {\n      const integration = dynamicRequire(module, './integrations/node/postgres')\n\n;\n      return new integration.Postgres();\n    },\n  };\n\n  const mappedPackages = Object.keys(packageToIntegrationMapping)\n    .filter(moduleName => !!loadModule(moduleName))\n    .map(pkg => {\n      try {\n        return packageToIntegrationMapping[pkg]();\n      } catch (e) {\n        return undefined;\n      }\n    })\n    .filter(p => p) ;\n\n  if (mappedPackages.length > 0) {\n    carrier.__SENTRY__.integrations = [...(carrier.__SENTRY__.integrations || []), ...mappedPackages];\n  }\n}\n\n/**\n * This patches the global object and injects the Tracing extensions methods\n */\nfunction addExtensionMethods() {\n  _addTracingExtensions();\n\n  // Detect and automatically load specified integrations.\n  if (isNodeEnv()) {\n    _autoloadDatabaseIntegrations();\n  }\n\n  // If an error happens globally, we should make sure transaction status is set to error.\n  registerErrorInstrumentation();\n}\n\nexport { _addTracingExtensions, addExtensionMethods, startIdleTransaction };\n//# sourceMappingURL=hubextensions.js.map\n","import { _nullishCoalesce } from '@sentry/utils/esm/buildPolyfills';\nimport { uuid4, timestampWithMs, logger, dropUndefinedKeys } from '@sentry/utils';\n\n/**\n * Keeps track of finished spans for a given transaction\n * @internal\n * @hideconstructor\n * @hidden\n */\nclass SpanRecorder {\n   __init() {this.spans = [];}\n\n   constructor(maxlen = 1000) {;SpanRecorder.prototype.__init.call(this);\n    this._maxlen = maxlen;\n  }\n\n  /**\n   * This is just so that we don't run out of memory while recording a lot\n   * of spans. At some point we just stop and flush out the start of the\n   * trace tree (i.e.the first n spans with the smallest\n   * start_timestamp).\n   */\n   add(span) {\n    if (this.spans.length > this._maxlen) {\n      span.spanRecorder = undefined;\n    } else {\n      this.spans.push(span);\n    }\n  }\n}\n\n/**\n * Span contains all data about a span\n */\nclass Span  {\n  /**\n   * @inheritDoc\n   */\n   __init2() {this.traceId = uuid4();}\n\n  /**\n   * @inheritDoc\n   */\n   __init3() {this.spanId = uuid4().substring(16);}\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * Internal keeper of the status\n   */\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * Timestamp in seconds when the span was created.\n   */\n   __init4() {this.startTimestamp = timestampWithMs();}\n\n  /**\n   * Timestamp in seconds when the span ended.\n   */\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * @inheritDoc\n   */\n   __init5() {this.tags = {};}\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n   __init6() {this.data = {};}\n\n  /**\n   * List of spans that were finalized\n   */\n\n  /**\n   * @inheritDoc\n   */\n\n  /**\n   * The instrumenter that created this span.\n   */\n   __init7() {this.instrumenter = 'sentry';}\n\n  /**\n   * You should never call the constructor manually, always use `Sentry.startTransaction()`\n   * or call `startChild()` on an existing span.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(spanContext) {;Span.prototype.__init2.call(this);Span.prototype.__init3.call(this);Span.prototype.__init4.call(this);Span.prototype.__init5.call(this);Span.prototype.__init6.call(this);Span.prototype.__init7.call(this);\n    if (!spanContext) {\n      return this;\n    }\n    if (spanContext.traceId) {\n      this.traceId = spanContext.traceId;\n    }\n    if (spanContext.spanId) {\n      this.spanId = spanContext.spanId;\n    }\n    if (spanContext.parentSpanId) {\n      this.parentSpanId = spanContext.parentSpanId;\n    }\n    // We want to include booleans as well here\n    if ('sampled' in spanContext) {\n      this.sampled = spanContext.sampled;\n    }\n    if (spanContext.op) {\n      this.op = spanContext.op;\n    }\n    if (spanContext.description) {\n      this.description = spanContext.description;\n    }\n    if (spanContext.data) {\n      this.data = spanContext.data;\n    }\n    if (spanContext.tags) {\n      this.tags = spanContext.tags;\n    }\n    if (spanContext.status) {\n      this.status = spanContext.status;\n    }\n    if (spanContext.startTimestamp) {\n      this.startTimestamp = spanContext.startTimestamp;\n    }\n    if (spanContext.endTimestamp) {\n      this.endTimestamp = spanContext.endTimestamp;\n    }\n    if (spanContext.instrumenter) {\n      this.instrumenter = spanContext.instrumenter;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   startChild(\n    spanContext,\n  ) {\n    const childSpan = new Span({\n      ...spanContext,\n      parentSpanId: this.spanId,\n      sampled: this.sampled,\n      traceId: this.traceId,\n    });\n\n    childSpan.spanRecorder = this.spanRecorder;\n    if (childSpan.spanRecorder) {\n      childSpan.spanRecorder.add(childSpan);\n    }\n\n    childSpan.transaction = this.transaction;\n\n    if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && childSpan.transaction) {\n      const opStr = (spanContext && spanContext.op) || '< unknown op >';\n      const nameStr = childSpan.transaction.name || '< unknown name >';\n      const idStr = childSpan.transaction.spanId;\n\n      const logMessage = `[Tracing] Starting '${opStr}' span on transaction '${nameStr}' (${idStr}).`;\n      childSpan.transaction.metadata.spanMetadata[childSpan.spanId] = { logMessage };\n      logger.log(logMessage);\n    }\n\n    return childSpan;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setTag(key, value) {\n    this.tags = { ...this.tags, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n   setData(key, value) {\n    this.data = { ...this.data, [key]: value };\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setStatus(value) {\n    this.status = value;\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setHttpStatus(httpStatus) {\n    this.setTag('http.status_code', String(httpStatus));\n    const spanStatus = spanStatusfromHttpCode(httpStatus);\n    if (spanStatus !== 'unknown_error') {\n      this.setStatus(spanStatus);\n    }\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   isSuccess() {\n    return this.status === 'ok';\n  }\n\n  /**\n   * @inheritDoc\n   */\n   finish(endTimestamp) {\n    if (\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      // Don't call this for transactions\n      this.transaction &&\n      this.transaction.spanId !== this.spanId\n    ) {\n      const { logMessage } = this.transaction.metadata.spanMetadata[this.spanId];\n      if (logMessage) {\n        logger.log((logMessage ).replace('Starting', 'Finishing'));\n      }\n    }\n\n    this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toTraceparent() {\n    let sampledString = '';\n    if (this.sampled !== undefined) {\n      sampledString = this.sampled ? '-1' : '-0';\n    }\n    return `${this.traceId}-${this.spanId}${sampledString}`;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toContext() {\n    return dropUndefinedKeys({\n      data: this.data,\n      description: this.description,\n      endTimestamp: this.endTimestamp,\n      op: this.op,\n      parentSpanId: this.parentSpanId,\n      sampled: this.sampled,\n      spanId: this.spanId,\n      startTimestamp: this.startTimestamp,\n      status: this.status,\n      tags: this.tags,\n      traceId: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateWithContext(spanContext) {\n    this.data = _nullishCoalesce(spanContext.data, () => ( {}));\n    this.description = spanContext.description;\n    this.endTimestamp = spanContext.endTimestamp;\n    this.op = spanContext.op;\n    this.parentSpanId = spanContext.parentSpanId;\n    this.sampled = spanContext.sampled;\n    this.spanId = _nullishCoalesce(spanContext.spanId, () => ( this.spanId));\n    this.startTimestamp = _nullishCoalesce(spanContext.startTimestamp, () => ( this.startTimestamp));\n    this.status = spanContext.status;\n    this.tags = _nullishCoalesce(spanContext.tags, () => ( {}));\n    this.traceId = _nullishCoalesce(spanContext.traceId, () => ( this.traceId));\n\n    return this;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   getTraceContext()\n\n {\n    return dropUndefinedKeys({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      trace_id: this.traceId,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toJSON()\n\n {\n    return dropUndefinedKeys({\n      data: Object.keys(this.data).length > 0 ? this.data : undefined,\n      description: this.description,\n      op: this.op,\n      parent_span_id: this.parentSpanId,\n      span_id: this.spanId,\n      start_timestamp: this.startTimestamp,\n      status: this.status,\n      tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,\n      timestamp: this.endTimestamp,\n      trace_id: this.traceId,\n    });\n  }\n}\n\n/**\n * Converts a HTTP status code into a {@link SpanStatusType}.\n *\n * @param httpStatus The HTTP response status code.\n * @returns The span status or unknown_error.\n */\nfunction spanStatusfromHttpCode(httpStatus) {\n  if (httpStatus < 400 && httpStatus >= 100) {\n    return 'ok';\n  }\n\n  if (httpStatus >= 400 && httpStatus < 500) {\n    switch (httpStatus) {\n      case 401:\n        return 'unauthenticated';\n      case 403:\n        return 'permission_denied';\n      case 404:\n        return 'not_found';\n      case 409:\n        return 'already_exists';\n      case 413:\n        return 'failed_precondition';\n      case 429:\n        return 'resource_exhausted';\n      default:\n        return 'invalid_argument';\n    }\n  }\n\n  if (httpStatus >= 500 && httpStatus < 600) {\n    switch (httpStatus) {\n      case 501:\n        return 'unimplemented';\n      case 503:\n        return 'unavailable';\n      case 504:\n        return 'deadline_exceeded';\n      default:\n        return 'internal_error';\n    }\n  }\n\n  return 'unknown_error';\n}\n\nexport { Span, SpanRecorder, spanStatusfromHttpCode };\n//# sourceMappingURL=span.js.map\n","import { _nullishCoalesce } from '@sentry/utils/esm/buildPolyfills';\nimport { getCurrentHub } from '@sentry/core';\nimport { timestampInSeconds, logger, dropUndefinedKeys } from '@sentry/utils';\nimport { Span, SpanRecorder } from './span.js';\n\n/** JSDoc */\nclass Transaction extends Span  {\n\n  /**\n   * The reference to the current hub.\n   */\n\n   __init() {this._measurements = {};}\n\n   __init2() {this._contexts = {};}\n\n   __init3() {this._frozenDynamicSamplingContext = undefined;}\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n   constructor(transactionContext, hub) {\n    super(transactionContext);Transaction.prototype.__init.call(this);Transaction.prototype.__init2.call(this);Transaction.prototype.__init3.call(this);;\n\n    this._hub = hub || getCurrentHub();\n\n    this._name = transactionContext.name || '';\n\n    this.metadata = {\n      source: 'custom',\n      ...transactionContext.metadata,\n      spanMetadata: {},\n      changes: [],\n      propagations: 0,\n    };\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n\n    // If Dynamic Sampling Context is provided during the creation of the transaction, we freeze it as it usually means\n    // there is incoming Dynamic Sampling Context. (Either through an incoming request, a baggage meta-tag, or other means)\n    const incomingDynamicSamplingContext = this.metadata.dynamicSamplingContext;\n    if (incomingDynamicSamplingContext) {\n      // We shallow copy this in case anything writes to the original reference of the passed in `dynamicSamplingContext`\n      this._frozenDynamicSamplingContext = { ...incomingDynamicSamplingContext };\n    }\n  }\n\n  /** Getter for `name` property */\n   get name() {\n    return this._name;\n  }\n\n  /** Setter for `name` property, which also sets `source` as custom */\n   set name(newName) {\n    this.setName(newName);\n  }\n\n  /**\n   * JSDoc\n   */\n   setName(name, source = 'custom') {\n    // `source` could change without the name changing if we discover that an unparameterized route is actually\n    // parameterized by virtue of having no parameters in its path\n    if (name !== this.name || source !== this.metadata.source) {\n      this.metadata.changes.push({\n        // log previous source\n        source: this.metadata.source,\n        timestamp: timestampInSeconds(),\n        propagations: this.metadata.propagations,\n      });\n    }\n\n    this._name = name;\n    this.metadata.source = source;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n   initSpanRecorder(maxlen = 1000) {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setMeasurement(name, value, unit = '') {\n    this._measurements[name] = { value, unit };\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setMetadata(newMetadata) {\n    this.metadata = { ...this.metadata, ...newMetadata };\n  }\n\n  /**\n   * @inheritDoc\n   */\n   finish(endTimestamp) {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n\n      const client = this._hub.getClient();\n      if (client) {\n        client.recordDroppedEvent('sample_rate', 'transaction');\n      }\n\n      return undefined;\n    }\n\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev, current) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    const metadata = this.metadata;\n\n    const transaction = {\n      contexts: {\n        ...this._contexts,\n        // We don't want to override trace context\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        ...metadata,\n        dynamicSamplingContext: this.getDynamicSamplingContext(),\n      },\n      ...(metadata.source && {\n        transaction_info: {\n          source: metadata.source,\n          changes: metadata.changes,\n          propagations: metadata.propagations,\n        },\n      }),\n    };\n\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.log(\n          '[Measurements] Adding measurements to transaction',\n          JSON.stringify(this._measurements, undefined, 2),\n        );\n      transaction.measurements = this._measurements;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   toContext() {\n    const spanContext = super.toContext();\n\n    return dropUndefinedKeys({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd,\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n   updateWithContext(transactionContext) {\n    super.updateWithContext(transactionContext);\n\n    this.name = _nullishCoalesce(transactionContext.name, () => ( ''));\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @experimental\n   */\n   getDynamicSamplingContext() {\n    if (this._frozenDynamicSamplingContext) {\n      return this._frozenDynamicSamplingContext;\n    }\n\n    const hub = this._hub || getCurrentHub();\n    const client = hub && hub.getClient();\n\n    if (!client) return {};\n\n    const { environment, release } = client.getOptions() || {};\n    const { publicKey: public_key } = client.getDsn() || {};\n\n    const maybeSampleRate = this.metadata.sampleRate;\n    const sample_rate = maybeSampleRate !== undefined ? maybeSampleRate.toString() : undefined;\n\n    const scope = hub.getScope();\n    const { segment: user_segment } = (scope && scope.getUser()) || {};\n\n    const source = this.metadata.source;\n\n    // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n    const transaction = source && source !== 'url' ? this.name : undefined;\n\n    const dsc = dropUndefinedKeys({\n      environment,\n      release,\n      transaction,\n      user_segment,\n      public_key,\n      trace_id: this.traceId,\n      sample_rate,\n    });\n\n    // Uncomment if we want to make DSC immutable\n    // this._frozenDynamicSamplingContext = dsc;\n\n    return dsc;\n  }\n}\n\nexport { Transaction };\n//# sourceMappingURL=transaction.js.map\n","import { timestampWithMs, logger } from '@sentry/utils';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\n\nconst DEFAULT_IDLE_TIMEOUT = 1000;\nconst DEFAULT_FINAL_TIMEOUT = 30000;\nconst DEFAULT_HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nclass IdleTransactionSpanRecorder extends SpanRecorder {\n   constructor(\n      _pushActivity,\n      _popActivity,\n     transactionSpanId,\n    maxlen,\n  ) {\n    super(maxlen);this._pushActivity = _pushActivity;this._popActivity = _popActivity;this.transactionSpanId = transactionSpanId;;\n  }\n\n  /**\n   * @inheritDoc\n   */\n   add(span) {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nclass IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n   __init() {this.activities = {};}\n\n  // Track state of activities in previous heartbeat\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n   __init2() {this._heartbeatCounter = 0;}\n\n  // We should not use heartbeat if we finished a transaction\n   __init3() {this._finished = false;}\n\n    __init4() {this._beforeFinishCallbacks = [];}\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n\n   constructor(\n    transactionContext,\n      _idleHub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished. This timer is started each time\n     * there are no active spans on this transaction.\n     */\n      _idleTimeout = DEFAULT_IDLE_TIMEOUT,\n    /**\n     * The final value in ms that a transaction cannot exceed\n     */\n      _finalTimeout = DEFAULT_FINAL_TIMEOUT,\n      _heartbeatInterval = DEFAULT_HEARTBEAT_INTERVAL,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n      _onScope = false,\n  ) {\n    super(transactionContext, _idleHub);this._idleHub = _idleHub;this._idleTimeout = _idleTimeout;this._finalTimeout = _finalTimeout;this._heartbeatInterval = _heartbeatInterval;this._onScope = _onScope;IdleTransaction.prototype.__init.call(this);IdleTransaction.prototype.__init2.call(this);IdleTransaction.prototype.__init3.call(this);IdleTransaction.prototype.__init4.call(this);;\n\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._startIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n   finish(endTimestamp = timestampWithMs()) {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n   registerBeforeFinishCallback(callback) {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   initSpanRecorder(maxlen) {\n    if (!this.spanRecorder) {\n      const pushActivity = (id) => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id) => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idletimeout, if there is one\n   */\n   _cancelIdleTimeout() {\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Creates an idletimeout\n   */\n   _startIdleTimeout(endTimestamp) {\n    this._cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n   _pushActivity(spanId) {\n    this._cancelIdleTimeout();\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n   _popActivity(spanId) {\n    if (this.activities[spanId]) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      const endTimestamp = timestampWithMs() + this._idleTimeout / 1000;\n      this._startIdleTimeout(endTimestamp);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n   _beat() {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n   _pingHeartbeat() {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub) {\n  const scope = hub.getScope();\n  if (scope) {\n    const transaction = scope.getTransaction();\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\n\nexport { DEFAULT_FINAL_TIMEOUT, DEFAULT_HEARTBEAT_INTERVAL, DEFAULT_IDLE_TIMEOUT, IdleTransaction, IdleTransactionSpanRecorder };\n//# sourceMappingURL=idletransaction.js.map\n","const TRACEPARENT_REGEXP = new RegExp(\n  '^[ \\\\t]*' + // whitespace\n    '([0-9a-f]{32})?' + // trace_id\n    '-?([0-9a-f]{16})?' + // span_id\n    '-?([01])?' + // sampled\n    '[ \\\\t]*$', // whitespace\n);\n\n/**\n * Extract transaction context data from a `sentry-trace` header.\n *\n * @param traceparent Traceparent string\n *\n * @returns Object containing data from the header, or undefined if traceparent string is malformed\n */\nfunction extractTraceparentData(traceparent) {\n  const matches = traceparent.match(TRACEPARENT_REGEXP);\n\n  if (!traceparent || !matches) {\n    // empty string or no matches is invalid traceparent data\n    return undefined;\n  }\n\n  let parentSampled;\n  if (matches[3] === '1') {\n    parentSampled = true;\n  } else if (matches[3] === '0') {\n    parentSampled = false;\n  }\n\n  return {\n    traceId: matches[1],\n    parentSampled,\n    parentSpanId: matches[2],\n  };\n}\n\nexport { TRACEPARENT_REGEXP, extractTraceparentData };\n//# sourceMappingURL=tracing.js.map\n","import { isString } from './is.js';\nimport { logger } from './logger.js';\n\nconst BAGGAGE_HEADER_NAME = 'baggage';\n\nconst SENTRY_BAGGAGE_KEY_PREFIX = 'sentry-';\n\nconst SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;\n\n/**\n * Max length of a serialized baggage string\n *\n * https://www.w3.org/TR/baggage/#limits\n */\nconst MAX_BAGGAGE_STRING_LENGTH = 8192;\n\n/**\n * Takes a baggage header and turns it into Dynamic Sampling Context, by extracting all the \"sentry-\" prefixed values\n * from it.\n *\n * @param baggageHeader A very bread definition of a baggage header as it might appear in various frameworks.\n * @returns The Dynamic Sampling Context that was found on `baggageHeader`, if there was any, `undefined` otherwise.\n */\nfunction baggageHeaderToDynamicSamplingContext(\n  // Very liberal definition of what any incoming header might look like\n  baggageHeader,\n) {\n  if (!isString(baggageHeader) && !Array.isArray(baggageHeader)) {\n    return undefined;\n  }\n\n  // Intermediary object to store baggage key value pairs of incoming baggage headers on.\n  // It is later used to read Sentry-DSC-values from.\n  let baggageObject = {};\n\n  if (Array.isArray(baggageHeader)) {\n    // Combine all baggage headers into one object containing the baggage values so we can later read the Sentry-DSC-values from it\n    baggageObject = baggageHeader.reduce((acc, curr) => {\n      const currBaggageObject = baggageHeaderToObject(curr);\n      return {\n        ...acc,\n        ...currBaggageObject,\n      };\n    }, {});\n  } else {\n    // Return undefined if baggage header is an empty string (technically an empty baggage header is not spec conform but\n    // this is how we choose to handle it)\n    if (!baggageHeader) {\n      return undefined;\n    }\n\n    baggageObject = baggageHeaderToObject(baggageHeader);\n  }\n\n  // Read all \"sentry-\" prefixed values out of the baggage object and put it onto a dynamic sampling context object.\n  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {\n    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {\n      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);\n      acc[nonPrefixedKey] = value;\n    }\n    return acc;\n  }, {});\n\n  // Only return a dynamic sampling context object if there are keys in it.\n  // A keyless object means there were no sentry values on the header, which means that there is no DSC.\n  if (Object.keys(dynamicSamplingContext).length > 0) {\n    return dynamicSamplingContext ;\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Turns a Dynamic Sampling Object into a baggage header by prefixing all the keys on the object with \"sentry-\".\n *\n * @param dynamicSamplingContext The Dynamic Sampling Context to turn into a header. For convenience and compatibility\n * with the `getDynamicSamplingContext` method on the Transaction class ,this argument can also be `undefined`. If it is\n * `undefined` the function will return `undefined`.\n * @returns a baggage header, created from `dynamicSamplingContext`, or `undefined` either if `dynamicSamplingContext`\n * was `undefined`, or if `dynamicSamplingContext` didn't contain any values.\n */\nfunction dynamicSamplingContextToSentryBaggageHeader(\n  // this also takes undefined for convenience and bundle size in other places\n  dynamicSamplingContext,\n) {\n  // Prefix all DSC keys with \"sentry-\" and put them into a new object\n  const sentryPrefixedDSC = Object.entries(dynamicSamplingContext).reduce(\n    (acc, [dscKey, dscValue]) => {\n      if (dscValue) {\n        acc[`${SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`] = dscValue;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  return objectToBaggageHeader(sentryPrefixedDSC);\n}\n\n/**\n * Will parse a baggage header, which is a simple key-value map, into a flat object.\n *\n * @param baggageHeader The baggage header to parse.\n * @returns a flat object containing all the key-value pairs from `baggageHeader`.\n */\nfunction baggageHeaderToObject(baggageHeader) {\n  return baggageHeader\n    .split(',')\n    .map(baggageEntry => baggageEntry.split('=').map(keyOrValue => decodeURIComponent(keyOrValue.trim())))\n    .reduce((acc, [key, value]) => {\n      acc[key] = value;\n      return acc;\n    }, {});\n}\n\n/**\n * Turns a flat object (key-value pairs) into a baggage header, which is also just key-value pairs.\n *\n * @param object The object to turn into a baggage header.\n * @returns a baggage header string, or `undefined` if the object didn't have any values, since an empty baggage header\n * is not spec compliant.\n */\nfunction objectToBaggageHeader(object) {\n  if (Object.keys(object).length === 0) {\n    // An empty baggage header is not spec compliant: We return undefined.\n    return undefined;\n  }\n\n  return Object.entries(object).reduce((baggageHeader, [objectKey, objectValue], currentIndex) => {\n    const baggageEntry = `${encodeURIComponent(objectKey)}=${encodeURIComponent(objectValue)}`;\n    const newBaggageHeader = currentIndex === 0 ? baggageEntry : `${baggageHeader},${baggageEntry}`;\n    if (newBaggageHeader.length > MAX_BAGGAGE_STRING_LENGTH) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn(\n          `Not adding key: ${objectKey} with val: ${objectValue} to baggage header due to exceeding baggage size limits.`,\n        );\n      return baggageHeader;\n    } else {\n      return newBaggageHeader;\n    }\n  }, '');\n}\n\nexport { BAGGAGE_HEADER_NAME, MAX_BAGGAGE_STRING_LENGTH, SENTRY_BAGGAGE_KEY_PREFIX, SENTRY_BAGGAGE_KEY_PREFIX_REGEX, baggageHeaderToDynamicSamplingContext, dynamicSamplingContextToSentryBaggageHeader };\n//# sourceMappingURL=baggage.js.map\n","import { GLOBAL_OBJ } from '@sentry/utils';\n\nconst WINDOW = GLOBAL_OBJ ;\n\nexport { WINDOW };\n//# sourceMappingURL=types.js.map\n","import { logger } from '@sentry/utils';\nimport { getActiveTransaction } from '../utils.js';\nimport { WINDOW } from './types.js';\n\n/**\n * Add a listener that cancels and finishes a transaction when the global\n * document is hidden.\n */\nfunction registerBackgroundTabDetection() {\n  if (WINDOW && WINDOW.document) {\n    WINDOW.document.addEventListener('visibilitychange', () => {\n      const activeTransaction = getActiveTransaction() ;\n      if (WINDOW.document.hidden && activeTransaction) {\n        const statusType = 'cancelled';\n\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n          logger.log(\n            `[Tracing] Transaction: ${statusType} -> since tab moved to the background, op: ${activeTransaction.op}`,\n          );\n        // We should not set status if it is already set, this prevent important statuses like\n        // error or data loss from being overwritten on transaction.\n        if (!activeTransaction.status) {\n          activeTransaction.setStatus(statusType);\n        }\n        activeTransaction.setTag('visibilitychange', 'document.hidden');\n        activeTransaction.finish();\n      }\n    });\n  } else {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n      logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');\n  }\n}\n\nexport { registerBackgroundTabDetection };\n//# sourceMappingURL=backgroundtab.js.map\n","const bindReporter = (\n  callback,\n  metric,\n  reportAllChanges,\n) => {\n  let prevValue;\n  let delta;\n  return (forceReport) => {\n    if (metric.value >= 0) {\n      if (forceReport || reportAllChanges) {\n        delta = metric.value - (prevValue || 0);\n\n        // Report the metric if there's a non-zero delta or if no previous\n        // value exists (which can happen in the case of the document becoming\n        // hidden when the metric value is 0).\n        // See: https://github.com/GoogleChrome/web-vitals/issues/14\n        if (delta || prevValue === undefined) {\n          prevValue = metric.value;\n          metric.delta = delta;\n          callback(metric);\n        }\n      }\n    }\n  };\n};\n\nexport { bindReporter };\n//# sourceMappingURL=bindReporter.js.map\n","/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Performantly generate a unique, 30-char string by combining a version\n * number, the current timestamp with a 13-digit number integer.\n * @return {string}\n */\nconst generateUniqueID = () => {\n  return `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n};\n\nexport { generateUniqueID };\n//# sourceMappingURL=generateUniqueID.js.map\n","import { WINDOW } from '../../types.js';\n\n/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst getNavigationEntryFromPerformanceTiming = () => {\n  // eslint-disable-next-line deprecation/deprecation\n  const timing = WINDOW.performance.timing;\n  // eslint-disable-next-line deprecation/deprecation\n  const type = WINDOW.performance.navigation.type;\n\n  const navigationEntry = {\n    entryType: 'navigation',\n    startTime: 0,\n    type: type == 2 ? 'back_forward' : type === 1 ? 'reload' : 'navigate',\n  };\n\n  for (const key in timing) {\n    if (key !== 'navigationStart' && key !== 'toJSON') {\n      navigationEntry[key] = Math.max((timing[key ] ) - timing.navigationStart, 0);\n    }\n  }\n  return navigationEntry ;\n};\n\nconst getNavigationEntry = () => {\n  if (WINDOW.__WEB_VITALS_POLYFILL__) {\n    return (\n      WINDOW.performance &&\n      ((performance.getEntriesByType && performance.getEntriesByType('navigation')[0]) ||\n        getNavigationEntryFromPerformanceTiming())\n    );\n  } else {\n    return WINDOW.performance && performance.getEntriesByType && performance.getEntriesByType('navigation')[0];\n  }\n};\n\nexport { getNavigationEntry };\n//# sourceMappingURL=getNavigationEntry.js.map\n","import { getNavigationEntry } from './getNavigationEntry.js';\n\n/*\n * Copyright 2022 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst getActivationStart = () => {\n  const navEntry = getNavigationEntry();\n  return (navEntry && navEntry.activationStart) || 0;\n};\n\nexport { getActivationStart };\n//# sourceMappingURL=getActivationStart.js.map\n","import { WINDOW } from '../../types.js';\nimport { generateUniqueID } from './generateUniqueID.js';\nimport { getActivationStart } from './getActivationStart.js';\nimport { getNavigationEntry } from './getNavigationEntry.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst initMetric = (name, value) => {\n  const navEntry = getNavigationEntry();\n  let navigationType = 'navigate';\n\n  if (navEntry) {\n    if (WINDOW.document.prerendering || getActivationStart() > 0) {\n      navigationType = 'prerender';\n    } else {\n      navigationType = navEntry.type.replace(/_/g, '-') ;\n    }\n  }\n\n  return {\n    name,\n    value: typeof value === 'undefined' ? -1 : value,\n    rating: 'good', // Will be updated if the value changes.\n    delta: 0,\n    entries: [],\n    id: generateUniqueID(),\n    navigationType,\n  };\n};\n\nexport { initMetric };\n//# sourceMappingURL=initMetric.js.map\n","/**\n * Takes a performance entry type and a callback function, and creates a\n * `PerformanceObserver` instance that will observe the specified entry type\n * with buffering enabled and call the callback _for each entry_.\n *\n * This function also feature-detects entry support and wraps the logic in a\n * try/catch to avoid errors in unsupporting browsers.\n */\nconst observe = (\n  type,\n  callback,\n  opts,\n) => {\n  try {\n    if (PerformanceObserver.supportedEntryTypes.includes(type)) {\n      const po = new PerformanceObserver(list => {\n        callback(list.getEntries() );\n      });\n      po.observe(\n        Object.assign(\n          {\n            type,\n            buffered: true,\n          },\n          opts || {},\n        ) ,\n      );\n      return po;\n    }\n  } catch (e) {\n    // Do nothing.\n  }\n  return;\n};\n\nexport { observe };\n//# sourceMappingURL=observe.js.map\n","import { WINDOW } from '../../types.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst onHidden = (cb, once) => {\n  const onHiddenOrPageHide = (event) => {\n    if (event.type === 'pagehide' || WINDOW.document.visibilityState === 'hidden') {\n      cb(event);\n      if (once) {\n        removeEventListener('visibilitychange', onHiddenOrPageHide, true);\n        removeEventListener('pagehide', onHiddenOrPageHide, true);\n      }\n    }\n  };\n  addEventListener('visibilitychange', onHiddenOrPageHide, true);\n  // Some browsers have buggy implementations of visibilitychange,\n  // so we use pagehide in addition, just to be safe.\n  addEventListener('pagehide', onHiddenOrPageHide, true);\n};\n\nexport { onHidden };\n//# sourceMappingURL=onHidden.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Calculates the [CLS](https://web.dev/cls/) value for the current page and\n * calls the `callback` function once the value is ready to be reported, along\n * with all `layout-shift` performance entries that were used in the metric\n * value calculation. The reported value is a `double` (corresponding to a\n * [layout shift score](https://web.dev/cls/#layout-shift-score)).\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called as soon as the value is initially\n * determined as well as any time the value changes throughout the page\n * lifespan.\n *\n * _**Important:** CLS should be continually monitored for changes throughout\n * the entire lifespan of a pageincluding if the user returns to the page after\n * it's been hidden/backgrounded. However, since browsers often [will not fire\n * additional callbacks once the user has backgrounded a\n * page](https://developer.chrome.com/blog/page-lifecycle-api/#advice-hidden),\n * `callback` is always called when the page's visibility state changes to\n * hidden. As a result, the `callback` function might be called multiple times\n * during the same page load._\n */\nconst onCLS = (onReport, opts = {}) => {\n  const metric = initMetric('CLS', 0);\n  let report;\n\n  let sessionValue = 0;\n  let sessionEntries = [];\n\n  // const handleEntries = (entries: Metric['entries']) => {\n  const handleEntries = (entries) => {\n    entries.forEach(entry => {\n      // Only count layout shifts without recent user input.\n      if (!entry.hadRecentInput) {\n        const firstSessionEntry = sessionEntries[0];\n        const lastSessionEntry = sessionEntries[sessionEntries.length - 1];\n\n        // If the entry occurred less than 1 second after the previous entry and\n        // less than 5 seconds after the first entry in the session, include the\n        // entry in the current session. Otherwise, start a new session.\n        if (\n          sessionValue &&\n          sessionEntries.length !== 0 &&\n          entry.startTime - lastSessionEntry.startTime < 1000 &&\n          entry.startTime - firstSessionEntry.startTime < 5000\n        ) {\n          sessionValue += entry.value;\n          sessionEntries.push(entry);\n        } else {\n          sessionValue = entry.value;\n          sessionEntries = [entry];\n        }\n\n        // If the current session value is larger than the current CLS value,\n        // update CLS and the entries contributing to it.\n        if (sessionValue > metric.value) {\n          metric.value = sessionValue;\n          metric.entries = sessionEntries;\n          if (report) {\n            report();\n          }\n        }\n      }\n    });\n  };\n\n  const po = observe('layout-shift', handleEntries);\n  if (po) {\n    report = bindReporter(onReport, metric, opts.reportAllChanges);\n\n    onHidden(() => {\n      handleEntries(po.takeRecords() );\n      report(true);\n    });\n  }\n};\n\nexport { onCLS };\n//# sourceMappingURL=getCLS.js.map\n","import { WINDOW } from '../../types.js';\nimport { onHidden } from './onHidden.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nlet firstHiddenTime = -1;\n\nconst initHiddenTime = () => {\n  // If the document is hidden and not prerendering, assume it was always\n  // hidden and the page was loaded in the background.\n  return WINDOW.document.visibilityState === 'hidden' && !WINDOW.document.prerendering ? 0 : Infinity;\n};\n\nconst trackChanges = () => {\n  // Update the time if/when the document becomes hidden.\n  onHidden(({ timeStamp }) => {\n    firstHiddenTime = timeStamp;\n  }, true);\n};\n\nconst getVisibilityWatcher = (\n\n) => {\n  if (firstHiddenTime < 0) {\n    // If the document is hidden when this code runs, assume it was hidden\n    // since navigation start. This isn't a perfect heuristic, but it's the\n    // best we can do until an API is available to support querying past\n    // visibilityState.\n    firstHiddenTime = initHiddenTime();\n    trackChanges();\n  }\n  return {\n    get firstHiddenTime() {\n      return firstHiddenTime;\n    },\n  };\n};\n\nexport { getVisibilityWatcher };\n//# sourceMappingURL=getVisibilityWatcher.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Calculates the [FID](https://web.dev/fid/) value for the current page and\n * calls the `callback` function once the value is ready, along with the\n * relevant `first-input` performance entry used to determine the value. The\n * reported value is a `DOMHighResTimeStamp`.\n *\n * _**Important:** since FID is only reported after the user interacts with the\n * page, it's possible that it will not be reported for some page loads._\n */\nconst onFID = (onReport, opts = {}) => {\n  const visibilityWatcher = getVisibilityWatcher();\n  const metric = initMetric('FID');\n  // eslint-disable-next-line prefer-const\n  let report;\n\n  const handleEntry = (entry) => {\n    // Only report if the page wasn't hidden prior to the first input.\n    if (entry.startTime < visibilityWatcher.firstHiddenTime) {\n      metric.value = entry.processingStart - entry.startTime;\n      metric.entries.push(entry);\n      report(true);\n    }\n  };\n\n  const handleEntries = (entries) => {\n    (entries ).forEach(handleEntry);\n  };\n\n  const po = observe('first-input', handleEntries);\n  report = bindReporter(onReport, metric, opts.reportAllChanges);\n\n  if (po) {\n    onHidden(() => {\n      handleEntries(po.takeRecords() );\n      po.disconnect();\n    }, true);\n  }\n};\n\nexport { onFID };\n//# sourceMappingURL=getFID.js.map\n","import { bindReporter } from './lib/bindReporter.js';\nimport { getActivationStart } from './lib/getActivationStart.js';\nimport { getVisibilityWatcher } from './lib/getVisibilityWatcher.js';\nimport { initMetric } from './lib/initMetric.js';\nimport { observe } from './lib/observe.js';\nimport { onHidden } from './lib/onHidden.js';\n\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst reportedMetricIDs = {};\n\n/**\n * Calculates the [LCP](https://web.dev/lcp/) value for the current page and\n * calls the `callback` function once the value is ready (along with the\n * relevant `largest-contentful-paint` performance entry used to determine the\n * value). The reported value is a `DOMHighResTimeStamp`.\n *\n * If the `reportAllChanges` configuration option is set to `true`, the\n * `callback` function will be called any time a new `largest-contentful-paint`\n * performance entry is dispatched, or once the final value of the metric has\n * been determined.\n */\nconst onLCP = (onReport, opts = {}) => {\n  const visibilityWatcher = getVisibilityWatcher();\n  const metric = initMetric('LCP');\n  let report;\n\n  const handleEntries = (entries) => {\n    const lastEntry = entries[entries.length - 1] ;\n    if (lastEntry) {\n      // The startTime attribute returns the value of the renderTime if it is\n      // not 0, and the value of the loadTime otherwise. The activationStart\n      // reference is used because LCP should be relative to page activation\n      // rather than navigation start if the page was prerendered.\n      const value = Math.max(lastEntry.startTime - getActivationStart(), 0);\n\n      // Only report if the page wasn't hidden prior to LCP.\n      if (value < visibilityWatcher.firstHiddenTime) {\n        metric.value = value;\n        metric.entries = [lastEntry];\n        report();\n      }\n    }\n  };\n\n  const po = observe('largest-contentful-paint', handleEntries);\n\n  if (po) {\n    report = bindReporter(onReport, metric, opts.reportAllChanges);\n\n    const stopListening = () => {\n      if (!reportedMetricIDs[metric.id]) {\n        handleEntries(po.takeRecords() );\n        po.disconnect();\n        reportedMetricIDs[metric.id] = true;\n        report(true);\n      }\n    };\n\n    // Stop listening after input. Note: while scrolling is an input that\n    // stop LCP observation, it's unreliable since it can be programmatically\n    // generated. See: https://github.com/GoogleChrome/web-vitals/issues/75\n    ['keydown', 'click'].forEach(type => {\n      addEventListener(type, stopListening, { once: true, capture: true });\n    });\n\n    onHidden(stopListening, true);\n  }\n};\n\nexport { onLCP };\n//# sourceMappingURL=getLCP.js.map\n","/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nfunction _startChild(transaction, { startTimestamp, ...ctx }) {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n\nexport { _startChild, isMeasurementValue };\n//# sourceMappingURL=utils.js.map\n","import { _nullishCoalesce } from '@sentry/utils/esm/buildPolyfills';\nimport { browserPerformanceTimeOrigin, logger, htmlTreeAsString } from '@sentry/utils';\nimport { getActiveTransaction, msToSec } from '../../utils.js';\nimport { WINDOW } from '../types.js';\nimport { onCLS } from '../web-vitals/getCLS.js';\nimport { onFID } from '../web-vitals/getFID.js';\nimport { onLCP } from '../web-vitals/getLCP.js';\nimport { getVisibilityWatcher } from '../web-vitals/lib/getVisibilityWatcher.js';\nimport { observe } from '../web-vitals/lib/observe.js';\nimport { _startChild, isMeasurementValue } from './utils.js';\n\nfunction getBrowserPerformanceAPI() {\n  return WINDOW && WINDOW.addEventListener && WINDOW.performance;\n}\n\nlet _performanceCursor = 0;\n\nlet _measurements = {};\nlet _lcpEntry;\nlet _clsEntry;\n\n/**\n * Start tracking web vitals\n */\nfunction startTrackingWebVitals(reportAllChanges = false) {\n  const performance = getBrowserPerformanceAPI();\n  if (performance && browserPerformanceTimeOrigin) {\n    if (performance.mark) {\n      WINDOW.performance.mark('sentry-tracing-init');\n    }\n    _trackCLS();\n    _trackLCP(reportAllChanges);\n    _trackFID();\n  }\n}\n\n/**\n * Start tracking long tasks.\n */\nfunction startTrackingLongTasks() {\n  const entryHandler = (entries) => {\n    for (const entry of entries) {\n      const transaction = getActiveTransaction() ;\n      if (!transaction) {\n        return;\n      }\n      const startTime = msToSec((browserPerformanceTimeOrigin ) + entry.startTime);\n      const duration = msToSec(entry.duration);\n\n      transaction.startChild({\n        description: 'Main UI thread blocked',\n        op: 'ui.long-task',\n        startTimestamp: startTime,\n        endTimestamp: startTime + duration,\n      });\n    }\n  };\n\n  observe('longtask', entryHandler);\n}\n\n/** Starts tracking the Cumulative Layout Shift on the current page. */\nfunction _trackCLS() {\n  // See:\n  // https://web.dev/evolving-cls/\n  // https://web.dev/cls-web-tooling/\n  onCLS(metric => {\n    const entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding CLS');\n    _measurements['cls'] = { value: metric.value, unit: '' };\n    _clsEntry = entry ;\n  });\n}\n\n/** Starts tracking the Largest Contentful Paint on the current page. */\nfunction _trackLCP(reportAllChanges) {\n  onLCP(\n    metric => {\n      const entry = metric.entries.pop();\n      if (!entry) {\n        return;\n      }\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding LCP');\n      _measurements['lcp'] = { value: metric.value, unit: 'millisecond' };\n      _lcpEntry = entry ;\n    },\n    { reportAllChanges },\n  );\n}\n\n/** Starts tracking the First Input Delay on the current page. */\nfunction _trackFID() {\n  onFID(metric => {\n    const entry = metric.entries.pop();\n    if (!entry) {\n      return;\n    }\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin );\n    const startTime = msToSec(entry.startTime);\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding FID');\n    _measurements['fid'] = { value: metric.value, unit: 'millisecond' };\n    _measurements['mark.fid'] = { value: timeOrigin + startTime, unit: 'second' };\n  });\n}\n\n/** Add performance related spans to a transaction */\nfunction addPerformanceEntries(transaction) {\n  const performance = getBrowserPerformanceAPI();\n  if (!performance || !WINDOW.performance.getEntries || !browserPerformanceTimeOrigin) {\n    // Gatekeeper if performance API not available\n    return;\n  }\n\n  (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Adding & adjusting spans using Performance API');\n  const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n\n  const performanceEntries = performance.getEntries();\n\n  let responseStartTimestamp;\n  let requestStartTimestamp;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  performanceEntries.slice(_performanceCursor).forEach((entry) => {\n    const startTime = msToSec(entry.startTime);\n    const duration = msToSec(entry.duration);\n\n    if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n      return;\n    }\n\n    switch (entry.entryType) {\n      case 'navigation': {\n        _addNavigationSpans(transaction, entry, timeOrigin);\n        responseStartTimestamp = timeOrigin + msToSec(entry.responseStart);\n        requestStartTimestamp = timeOrigin + msToSec(entry.requestStart);\n        break;\n      }\n      case 'mark':\n      case 'paint':\n      case 'measure': {\n        _addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n\n        // capture web vitals\n        const firstHidden = getVisibilityWatcher();\n        // Only report if the page wasn't hidden prior to the web vital.\n        const shouldRecord = entry.startTime < firstHidden.firstHiddenTime;\n\n        if (entry.name === 'first-paint' && shouldRecord) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding FP');\n          _measurements['fp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        if (entry.name === 'first-contentful-paint' && shouldRecord) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding FCP');\n          _measurements['fcp'] = { value: entry.startTime, unit: 'millisecond' };\n        }\n        break;\n      }\n      case 'resource': {\n        const resourceName = (entry.name ).replace(WINDOW.location.origin, '');\n        _addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n        break;\n      }\n      default:\n      // Ignore other entry types.\n    }\n  });\n\n  _performanceCursor = Math.max(performanceEntries.length - 1, 0);\n\n  _trackNavigator(transaction);\n\n  // Measurements are only available for pageload transactions\n  if (transaction.op === 'pageload') {\n    // Generate TTFB (Time to First Byte), which measured as the time between the beginning of the transaction and the\n    // start of the response in milliseconds\n    if (typeof responseStartTimestamp === 'number') {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding TTFB');\n      _measurements['ttfb'] = {\n        value: (responseStartTimestamp - transaction.startTimestamp) * 1000,\n        unit: 'millisecond',\n      };\n\n      if (typeof requestStartTimestamp === 'number' && requestStartTimestamp <= responseStartTimestamp) {\n        // Capture the time spent making the request and receiving the first byte of the response.\n        // This is the time between the start of the request and the start of the response in milliseconds.\n        _measurements['ttfb.requestTime'] = {\n          value: (responseStartTimestamp - requestStartTimestamp) * 1000,\n          unit: 'millisecond',\n        };\n      }\n    }\n\n    ['fcp', 'fp', 'lcp'].forEach(name => {\n      if (!_measurements[name] || timeOrigin >= transaction.startTimestamp) {\n        return;\n      }\n      // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n      // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n      // to be adjusted to be relative to transaction.startTimestamp.\n      const oldValue = _measurements[name].value;\n      const measurementTimestamp = timeOrigin + msToSec(oldValue);\n\n      // normalizedValue should be in milliseconds\n      const normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n      const delta = normalizedValue - oldValue;\n\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);\n      _measurements[name].value = normalizedValue;\n    });\n\n    const fidMark = _measurements['mark.fid'];\n    if (fidMark && _measurements['fid']) {\n      // create span for FID\n      _startChild(transaction, {\n        description: 'first input delay',\n        endTimestamp: fidMark.value + msToSec(_measurements['fid'].value),\n        op: 'ui.action',\n        startTimestamp: fidMark.value,\n      });\n\n      // Delete mark.fid as we don't want it to be part of final payload\n      delete _measurements['mark.fid'];\n    }\n\n    // If FCP is not recorded we should not record the cls value\n    // according to the new definition of CLS.\n    if (!('fcp' in _measurements)) {\n      delete _measurements.cls;\n    }\n\n    Object.keys(_measurements).forEach(measurementName => {\n      transaction.setMeasurement(\n        measurementName,\n        _measurements[measurementName].value,\n        _measurements[measurementName].unit,\n      );\n    });\n\n    _tagMetricInfo(transaction);\n  }\n\n  _lcpEntry = undefined;\n  _clsEntry = undefined;\n  _measurements = {};\n}\n\n/** Create measure related spans */\nfunction _addMeasureSpans(\n  transaction,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  entry,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  const measureStartTimestamp = timeOrigin + startTime;\n  const measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name ,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType ,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\n/** Instrument navigation entries */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _addNavigationSpans(transaction, entry, timeOrigin) {\n  ['unloadEvent', 'redirect', 'domContentLoadedEvent', 'loadEvent', 'connect'].forEach(event => {\n    _addPerformanceNavigationTiming(transaction, entry, event, timeOrigin);\n  });\n  _addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'TLS/SSL', 'connectEnd');\n  _addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'cache', 'domainLookupStart');\n  _addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin, 'DNS');\n  _addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create performance navigation related spans */\nfunction _addPerformanceNavigationTiming(\n  transaction,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  entry,\n  event,\n  timeOrigin,\n  description,\n  eventEnd,\n) {\n  const end = eventEnd ? (entry[eventEnd] ) : (entry[`${event}End`] );\n  const start = entry[`${event}Start`] ;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: _nullishCoalesce(description, () => ( event)),\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end),\n  });\n}\n\n/** Create request and response related spans */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _addRequest(transaction, entry, timeOrigin) {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart ),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd ),\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart ),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd ),\n  });\n}\n\n/** Create resource-related spans */\nfunction _addResourceSpans(\n  transaction,\n  entry,\n  resourceName,\n  startTime,\n  duration,\n  timeOrigin,\n) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const data = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource.other',\n    startTimestamp,\n    data,\n  });\n}\n\n/**\n * Capture the information of the user agent.\n */\nfunction _trackNavigator(transaction) {\n  const navigator = WINDOW.navigator ;\n  if (!navigator) {\n    return;\n  }\n\n  // track network connectivity\n  const connection = navigator.connection;\n  if (connection) {\n    if (connection.effectiveType) {\n      transaction.setTag('effectiveConnectionType', connection.effectiveType);\n    }\n\n    if (connection.type) {\n      transaction.setTag('connectionType', connection.type);\n    }\n\n    if (isMeasurementValue(connection.rtt)) {\n      _measurements['connection.rtt'] = { value: connection.rtt, unit: 'millisecond' };\n    }\n  }\n\n  if (isMeasurementValue(navigator.deviceMemory)) {\n    transaction.setTag('deviceMemory', `${navigator.deviceMemory} GB`);\n  }\n\n  if (isMeasurementValue(navigator.hardwareConcurrency)) {\n    transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n  }\n}\n\n/** Add LCP / CLS data to transaction to allow debugging */\nfunction _tagMetricInfo(transaction) {\n  if (_lcpEntry) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding LCP Data');\n\n    // Capture Properties of the LCP element that contributes to the LCP.\n\n    if (_lcpEntry.element) {\n      transaction.setTag('lcp.element', htmlTreeAsString(_lcpEntry.element));\n    }\n\n    if (_lcpEntry.id) {\n      transaction.setTag('lcp.id', _lcpEntry.id);\n    }\n\n    if (_lcpEntry.url) {\n      // Trim URL to the first 200 characters.\n      transaction.setTag('lcp.url', _lcpEntry.url.trim().slice(0, 200));\n    }\n\n    transaction.setTag('lcp.size', _lcpEntry.size);\n  }\n\n  // See: https://developer.mozilla.org/en-US/docs/Web/API/LayoutShift\n  if (_clsEntry && _clsEntry.sources) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding CLS Data');\n    _clsEntry.sources.forEach((source, index) =>\n      transaction.setTag(`cls.source.${index + 1}`, htmlTreeAsString(source.node)),\n    );\n  }\n}\n\nexport { _addMeasureSpans, _addResourceSpans, addPerformanceEntries, startTrackingLongTasks, startTrackingWebVitals };\n//# sourceMappingURL=index.js.map\n","import { addInstrumentationHandler, stringMatchesSomePattern, dynamicSamplingContextToSentryBaggageHeader, isInstanceOf, BAGGAGE_HEADER_NAME } from '@sentry/utils';\nimport { hasTracingEnabled, getActiveTransaction } from '../utils.js';\n\nconst DEFAULT_TRACE_PROPAGATION_TARGETS = ['localhost', /^\\//];\n\n/** Options for Request Instrumentation */\n\nconst defaultRequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  // TODO (v8): Remove this property\n  tracingOrigins: DEFAULT_TRACE_PROPAGATION_TARGETS,\n  tracePropagationTargets: DEFAULT_TRACE_PROPAGATION_TARGETS,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nfunction instrumentOutgoingRequests(_options) {\n  // eslint-disable-next-line deprecation/deprecation\n  const { traceFetch, traceXHR, tracePropagationTargets, tracingOrigins, shouldCreateSpanForRequest } = {\n    traceFetch: defaultRequestInstrumentationOptions.traceFetch,\n    traceXHR: defaultRequestInstrumentationOptions.traceXHR,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_) => true;\n\n  // TODO(v8) Remove tracingOrigins here\n  // The only reason we're passing it in here is because this instrumentOutgoingRequests function is publicly exported\n  // and we don't want to break the API. We can remove it in v8.\n  const shouldAttachHeadersWithTargets = (url) =>\n    shouldAttachHeaders(url, tracePropagationTargets || tracingOrigins);\n\n  const spans = {};\n\n  if (traceFetch) {\n    addInstrumentationHandler('fetch', (handlerData) => {\n      fetchCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n    });\n  }\n\n  if (traceXHR) {\n    addInstrumentationHandler('xhr', (handlerData) => {\n      xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n    });\n  }\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * This was extracted from `instrumentOutgoingRequests` to make it easier to test shouldAttachHeaders.\n * We only export this fuction for testing purposes.\n */\nfunction shouldAttachHeaders(url, tracePropagationTargets) {\n  return stringMatchesSomePattern(url, tracePropagationTargets || DEFAULT_TRACE_PROPAGATION_TARGETS);\n}\n\n/**\n * Create and track fetch request spans\n */\nfunction fetchCallback(\n  handlerData,\n  shouldCreateSpan,\n  shouldAttachHeaders,\n  spans,\n) {\n  if (!hasTracingEnabled() || !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {\n    return;\n  }\n\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.fetchData.__span;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      if (handlerData.response) {\n        // TODO (kmclb) remove this once types PR goes through\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        span.setHttpStatus(handlerData.response.status);\n      } else if (handlerData.error) {\n        span.setStatus('internal_error');\n      }\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const span = activeTransaction.startChild({\n      data: {\n        ...handlerData.fetchData,\n        type: 'fetch',\n      },\n      description: `${handlerData.fetchData.method} ${handlerData.fetchData.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.fetchData.__span = span.spanId;\n    spans[span.spanId] = span;\n\n    const request = handlerData.args[0];\n\n    // In case the user hasn't set the second argument of a fetch call we default it to `{}`.\n    handlerData.args[1] = handlerData.args[1] || {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const options = handlerData.args[1];\n\n    if (shouldAttachHeaders(handlerData.fetchData.url)) {\n      options.headers = addTracingHeadersToFetchRequest(\n        request,\n        activeTransaction.getDynamicSamplingContext(),\n        span,\n        options,\n      );\n\n      activeTransaction.metadata.propagations++;\n    }\n  }\n}\n\nfunction addTracingHeadersToFetchRequest(\n  request,\n  dynamicSamplingContext,\n  span,\n  options\n\n,\n) {\n  const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n  const sentryTraceHeader = span.toTraceparent();\n\n  const headers =\n    typeof Request !== 'undefined' && isInstanceOf(request, Request) ? (request ).headers : options.headers;\n\n  if (!headers) {\n    return { 'sentry-trace': sentryTraceHeader, baggage: sentryBaggageHeader };\n  } else if (typeof Headers !== 'undefined' && isInstanceOf(headers, Headers)) {\n    const newHeaders = new Headers(headers );\n\n    newHeaders.append('sentry-trace', sentryTraceHeader);\n\n    if (sentryBaggageHeader) {\n      // If the same header is appended miultiple times the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.append(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n    }\n\n    return newHeaders ;\n  } else if (Array.isArray(headers)) {\n    const newHeaders = [...headers, ['sentry-trace', sentryTraceHeader]];\n\n    if (sentryBaggageHeader) {\n      // If there are multiple entries with the same key, the browser will merge the values into a single request header.\n      // Its therefore safe to simply push a \"baggage\" entry, even though there might already be another baggage header.\n      newHeaders.push([BAGGAGE_HEADER_NAME, sentryBaggageHeader]);\n    }\n\n    return newHeaders;\n  } else {\n    const existingBaggageHeader = 'baggage' in headers ? headers.baggage : undefined;\n    const newBaggageHeaders = [];\n\n    if (Array.isArray(existingBaggageHeader)) {\n      newBaggageHeaders.push(...existingBaggageHeader);\n    } else if (existingBaggageHeader) {\n      newBaggageHeaders.push(existingBaggageHeader);\n    }\n\n    if (sentryBaggageHeader) {\n      newBaggageHeaders.push(sentryBaggageHeader);\n    }\n\n    return {\n      ...(headers ),\n      'sentry-trace': sentryTraceHeader,\n      baggage: newBaggageHeaders.length > 0 ? newBaggageHeaders.join(',') : undefined,\n    };\n  }\n}\n\n/**\n * Create and track xhr request spans\n */\nfunction xhrCallback(\n  handlerData,\n  shouldCreateSpan,\n  shouldAttachHeaders,\n  spans,\n) {\n  if (\n    !hasTracingEnabled() ||\n    (handlerData.xhr && handlerData.xhr.__sentry_own_request__) ||\n    !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url))\n  ) {\n    return;\n  }\n\n  const xhr = handlerData.xhr.__sentry_xhr__;\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp) {\n    const spanId = handlerData.xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span) {\n      span.setHttpStatus(xhr.status_code);\n      span.finish();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return;\n  }\n\n  // if not, create a new span to track it\n  const activeTransaction = getActiveTransaction();\n  if (activeTransaction) {\n    const span = activeTransaction.startChild({\n      data: {\n        ...xhr.data,\n        type: 'xhr',\n        method: xhr.method,\n        url: xhr.url,\n      },\n      description: `${xhr.method} ${xhr.url}`,\n      op: 'http.client',\n    });\n\n    handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;\n    spans[handlerData.xhr.__sentry_xhr_span_id__] = span;\n\n    if (handlerData.xhr.setRequestHeader && shouldAttachHeaders(handlerData.xhr.__sentry_xhr__.url)) {\n      try {\n        handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());\n\n        const dynamicSamplingContext = activeTransaction.getDynamicSamplingContext();\n        const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n\n        if (sentryBaggageHeader) {\n          // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n          // We can therefore simply set a baggage header without checking what was there before\n          // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n          handlerData.xhr.setRequestHeader(BAGGAGE_HEADER_NAME, sentryBaggageHeader);\n        }\n\n        activeTransaction.metadata.propagations++;\n      } catch (_) {\n        // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n      }\n    }\n  }\n}\n\nexport { DEFAULT_TRACE_PROPAGATION_TARGETS, defaultRequestInstrumentationOptions, fetchCallback, instrumentOutgoingRequests, shouldAttachHeaders, xhrCallback };\n//# sourceMappingURL=request.js.map\n","import { logger, addInstrumentationHandler } from '@sentry/utils';\nimport { WINDOW } from './types.js';\n\n/**\n * Default function implementing pageload and navigation transactions\n */\nfunction instrumentRoutingWithDefaults(\n  customStartTransaction,\n  startTransactionOnPageLoad = true,\n  startTransactionOnLocationChange = true,\n) {\n  if (!WINDOW || !WINDOW.location) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Could not initialize routing instrumentation due to invalid location');\n    return;\n  }\n\n  let startingUrl = WINDOW.location.href;\n\n  let activeTransaction;\n  if (startTransactionOnPageLoad) {\n    activeTransaction = customStartTransaction({\n      name: WINDOW.location.pathname,\n      op: 'pageload',\n      metadata: { source: 'url' },\n    });\n  }\n\n  if (startTransactionOnLocationChange) {\n    addInstrumentationHandler('history', ({ to, from }) => {\n      /**\n       * This early return is there to account for some cases where a navigation transaction starts right after\n       * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n       * create an uneccessary navigation transaction.\n       *\n       * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n       * only be caused in certain development environments where the usage of a hot module reloader is causing\n       * errors.\n       */\n      if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {\n        startingUrl = undefined;\n        return;\n      }\n\n      if (from !== to) {\n        startingUrl = undefined;\n        if (activeTransaction) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing current transaction with op: ${activeTransaction.op}`);\n          // If there's an open transaction on the scope, we need to finish it before creating an new one.\n          activeTransaction.finish();\n        }\n        activeTransaction = customStartTransaction({\n          name: WINDOW.location.pathname,\n          op: 'navigation',\n          metadata: { source: 'url' },\n        });\n      }\n    });\n  }\n}\n\nexport { instrumentRoutingWithDefaults };\n//# sourceMappingURL=router.js.map\n","import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { logger, extractTraceparentData, baggageHeaderToDynamicSamplingContext, getDomElement } from '@sentry/utils';\nimport { startIdleTransaction } from '../hubextensions.js';\nimport { DEFAULT_IDLE_TIMEOUT, DEFAULT_FINAL_TIMEOUT, DEFAULT_HEARTBEAT_INTERVAL } from '../idletransaction.js';\nimport '../utils.js';\nimport { registerBackgroundTabDetection } from './backgroundtab.js';\nimport { startTrackingWebVitals, startTrackingLongTasks, addPerformanceEntries } from './metrics/index.js';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request.js';\nimport { instrumentRoutingWithDefaults } from './router.js';\nimport { WINDOW } from './types.js';\n\nconst BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS = {\n  idleTimeout: DEFAULT_IDLE_TIMEOUT,\n  finalTimeout: DEFAULT_FINAL_TIMEOUT,\n  heartbeatInterval: DEFAULT_HEARTBEAT_INTERVAL,\n  markBackgroundTransactions: true,\n  routingInstrumentation: instrumentRoutingWithDefaults,\n  startTransactionOnLocationChange: true,\n  startTransactionOnPageLoad: true,\n  _experiments: { enableLongTask: true },\n  ...defaultRequestInstrumentationOptions,\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n */\nclass BrowserTracing  {\n  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented\n  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.\n  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all\n  // integrations.\n\n  /** Browser Tracing integration options */\n\n  /**\n   * @inheritDoc\n   */\n   __init() {this.name = BROWSER_TRACING_INTEGRATION_ID;}\n\n   constructor(_options) {;BrowserTracing.prototype.__init.call(this);\n    this.options = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options,\n    };\n\n    // TODO (v8): remove this block after tracingOrigins is removed\n    // Set tracePropagationTargets to tracingOrigins if specified by the user\n    // In case both are specified, tracePropagationTargets takes precedence\n    // eslint-disable-next-line deprecation/deprecation\n    if (_options && !_options.tracePropagationTargets && _options.tracingOrigins) {\n      // eslint-disable-next-line deprecation/deprecation\n      this.options.tracePropagationTargets = _options.tracingOrigins;\n    }\n\n    const { _metricOptions } = this.options;\n    startTrackingWebVitals(_metricOptions && _metricOptions._reportAllChanges);\n    if (_optionalChain([this, 'access', _2 => _2.options, 'access', _3 => _3._experiments, 'optionalAccess', _4 => _4.enableLongTask])) {\n      startTrackingLongTasks();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n   setupOnce(_, getCurrentHub) {\n    this._getCurrentHub = getCurrentHub;\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const {\n      routingInstrumentation: instrumentRouting,\n      startTransactionOnLocationChange,\n      startTransactionOnPageLoad,\n      markBackgroundTransactions,\n      traceFetch,\n      traceXHR,\n      tracePropagationTargets,\n      shouldCreateSpanForRequest,\n    } = this.options;\n\n    instrumentRouting(\n      (context) => this._createRouteTransaction(context),\n      startTransactionOnPageLoad,\n      startTransactionOnLocationChange,\n    );\n\n    if (markBackgroundTransactions) {\n      registerBackgroundTabDetection();\n    }\n\n    instrumentOutgoingRequests({\n      traceFetch,\n      traceXHR,\n      tracePropagationTargets,\n      shouldCreateSpanForRequest,\n    });\n  }\n\n  /** Create routing idle transaction. */\n   _createRouteTransaction(context) {\n    if (!this._getCurrentHub) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);\n      return undefined;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeNavigate, idleTimeout, finalTimeout, heartbeatInterval } = this.options;\n\n    const isPageloadTransaction = context.op === 'pageload';\n\n    const sentryTraceMetaTagValue = isPageloadTransaction ? getMetaContent('sentry-trace') : null;\n    const baggageMetaTagValue = isPageloadTransaction ? getMetaContent('baggage') : null;\n\n    const traceParentData = sentryTraceMetaTagValue ? extractTraceparentData(sentryTraceMetaTagValue) : undefined;\n    const dynamicSamplingContext = baggageMetaTagValue\n      ? baggageHeaderToDynamicSamplingContext(baggageMetaTagValue)\n      : undefined;\n\n    const expandedContext = {\n      ...context,\n      ...traceParentData,\n      metadata: {\n        ...context.metadata,\n        dynamicSamplingContext: traceParentData && !dynamicSamplingContext ? {} : dynamicSamplingContext,\n      },\n      trimEnd: true,\n    };\n\n    const modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    const finalContext = modifiedContext === undefined ? { ...expandedContext, sampled: false } : modifiedContext;\n\n    // If `beforeNavigate` set a custom name, record that fact\n    finalContext.metadata =\n      finalContext.name !== expandedContext.name\n        ? { ...finalContext.metadata, source: 'custom' }\n        : finalContext.metadata;\n\n    if (finalContext.sampled === false) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n\n    const hub = this._getCurrentHub();\n    const { location } = WINDOW;\n\n    const idleTransaction = startIdleTransaction(\n      hub,\n      finalContext,\n      idleTimeout,\n      finalTimeout,\n      true,\n      { location }, // for use in the tracesSampler\n      heartbeatInterval,\n    );\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      addPerformanceEntries(transaction);\n    });\n\n    return idleTransaction ;\n  }\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  const metaTag = getDomElement(`meta[name=${metaName}]`);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return metaTag ? metaTag.getAttribute('content') : null;\n}\n\nexport { BROWSER_TRACING_INTEGRATION_ID, BrowserTracing, getMetaContent };\n//# sourceMappingURL=browsertracing.js.map\n","import { addExtensionMethods } from './hubextensions.js';\nexport { addExtensionMethods, startIdleTransaction } from './hubextensions.js';\nimport * as index from './integrations/index.js';\nexport { index as Integrations };\nimport './browser/index.js';\nexport { Span, spanStatusfromHttpCode } from './span.js';\nexport { SpanStatus } from './spanstatus.js';\nexport { Transaction } from './transaction.js';\nexport { IdleTransaction } from './idletransaction.js';\nexport { getActiveTransaction, hasTracingEnabled } from './utils.js';\nexport { BROWSER_TRACING_INTEGRATION_ID, BrowserTracing } from './browser/browsertracing.js';\nexport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './browser/request.js';\nexport { TRACEPARENT_REGEXP, extractTraceparentData, stripUrlQueryAndFragment } from '@sentry/utils';\n\n;\n;\n\n// Treeshakable guard to remove all code related to tracing\n\n// Guard for tree\nif (typeof __SENTRY_TRACING__ === 'undefined' || __SENTRY_TRACING__) {\n  // We are patching the global object with our hub extension methods\n  addExtensionMethods();\n}\n//# sourceMappingURL=index.js.map\n","import { getCurrentHub } from '@sentry/core';\nexport { TRACEPARENT_REGEXP, extractTraceparentData, stripUrlQueryAndFragment } from '@sentry/utils';\n\n/**\n * Determines if tracing is currently enabled.\n *\n * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.\n */\nfunction hasTracingEnabled(\n  maybeOptions,\n) {\n  const client = getCurrentHub().getClient();\n  const options = maybeOptions || (client && client.getOptions());\n  return !!options && ('tracesSampleRate' in options || 'tracesSampler' in options);\n}\n\n/** Grabs active transaction off scope, if any */\nfunction getActiveTransaction(maybeHub) {\n  const hub = maybeHub || getCurrentHub();\n  const scope = hub.getScope();\n  return scope && (scope.getTransaction() );\n}\n\n/**\n * Converts from milliseconds to seconds\n * @param time time in ms\n */\nfunction msToSec(time) {\n  return time / 1000;\n}\n\n/**\n * Converts from seconds to milliseconds\n * @param time time in seconds\n */\nfunction secToMs(time) {\n  return time * 1000;\n}\n\nexport { getActiveTransaction, hasTracingEnabled, msToSec, secToMs };\n//# sourceMappingURL=utils.js.map\n","/**\n * Polyfill for the nullish coalescing operator (`??`).\n *\n * Note that the RHS is wrapped in a function so that if it's a computed value, that evaluation won't happen unless the\n * LHS evaluates to a nullish value, to mimic the operator's short-circuiting behavior.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n *\n * @param lhs The value of the expression to the left of the `??`\n * @param rhsFn A function returning the value of the expression to the right of the `??`\n * @returns The LHS value, unless it's `null` or `undefined`, in which case, the RHS value\n */\nfunction _nullishCoalesce(lhs, rhsFn) {\n  // by checking for loose equality to `null`, we catch both `null` and `undefined`\n  return lhs != null ? lhs : rhsFn();\n}\n\n// Sucrase version:\n// function _nullishCoalesce(lhs, rhsFn) {\n//   if (lhs != null) {\n//     return lhs;\n//   } else {\n//     return rhsFn();\n//   }\n// }\n\nexport { _nullishCoalesce };\n//# sourceMappingURL=_nullishCoalesce.js.map\n","/**\n * Polyfill for the optional chain operator, `?.`, given previous conversion of the expression into an array of values,\n * descriptors, and functions.\n *\n * Adapted from Sucrase (https://github.com/alangpierce/sucrase)\n * See https://github.com/alangpierce/sucrase/blob/265887868966917f3b924ce38dfad01fbab1329f/src/transformers/OptionalChainingNullishTransformer.ts#L15\n *\n * @param ops Array result of expression conversion\n * @returns The value of the expression\n */\nfunction _optionalChain(ops) {\n  let lastAccessLHS = undefined;\n  let value = ops[0];\n  let i = 1;\n  while (i < ops.length) {\n    const op = ops[i] ;\n    const fn = ops[i + 1] ;\n    i += 2;\n    // by checking for loose equality to `null`, we catch both `null` and `undefined`\n    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n      // really we're meaning to return `undefined` as an actual value here, but it saves bytes not to write it\n      return;\n    }\n    if (op === 'access' || op === 'optionalAccess') {\n      lastAccessLHS = value;\n      value = fn(value);\n    } else if (op === 'call' || op === 'optionalCall') {\n      value = fn((...args) => (value ).call(lastAccessLHS, ...args));\n      lastAccessLHS = undefined;\n    }\n  }\n  return value;\n}\n\n// Sucrase version\n// function _optionalChain(ops) {\n//   let lastAccessLHS = undefined;\n//   let value = ops[0];\n//   let i = 1;\n//   while (i < ops.length) {\n//     const op = ops[i];\n//     const fn = ops[i + 1];\n//     i += 2;\n//     if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {\n//       return undefined;\n//     }\n//     if (op === 'access' || op === 'optionalAccess') {\n//       lastAccessLHS = value;\n//       value = fn(value);\n//     } else if (op === 'call' || op === 'optionalCall') {\n//       value = fn((...args) => value.call(lastAccessLHS, ...args));\n//       lastAccessLHS = undefined;\n//     }\n//   }\n//   return value;\n// }\n\nexport { _optionalChain };\n//# sourceMappingURL=_optionalChain.js.map\n","import { isInstanceOf, isString } from './is.js';\nimport { logger, CONSOLE_LEVELS } from './logger.js';\nimport { fill } from './object.js';\nimport { getFunctionName } from './stacktrace.js';\nimport { supportsNativeFetch, supportsHistory } from './supports.js';\nimport { getGlobalObject } from './worldwide.js';\n\n// eslint-disable-next-line deprecation/deprecation\nconst WINDOW = getGlobalObject();\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers = {};\nconst instrumented = {};\n\n/** Instruments given API */\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nfunction addInstrumentationHandler(type, callback) {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] ).push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type, data) {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole() {\n  if (!('console' in WINDOW)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level) {\n    if (!(level in WINDOW.console)) {\n      return;\n    }\n\n    fill(WINDOW.console, level, function (originalConsoleMethod) {\n      return function (...args) {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(WINDOW.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(WINDOW, 'fetch', function (originalFetch) {\n    return function (...args) {\n      const handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(WINDOW, args).then(\n        (response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs = []) {\n  if ('Request' in WINDOW && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs = []) {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in WINDOW && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in WINDOW)) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function ( ...args) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const xhr = this;\n      const url = args[1];\n      const xhrInfo = (xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = function () {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhr.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original) {\n          return function (...readyStateArgs) {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend) {\n    return function ( ...args) {\n      if (this.__sentry_xhr__ && args[0] !== undefined) {\n        this.__sentry_xhr__.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref;\n\n/** JSDoc */\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = WINDOW.onpopstate;\n  WINDOW.onpopstate = function ( ...args) {\n    const to = WINDOW.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function ( ...args) {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(WINDOW.history, 'pushState', historyReplacementFunction);\n  fill(WINDOW.history, 'replaceState', historyReplacementFunction);\n}\n\nconst debounceDuration = 1000;\nlet debounceTimerID;\nlet lastCapturedEvent;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous, current) {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event) {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    const target = event.target ;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler, globalListener = false) {\n  return (event) => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = WINDOW.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\n/** JSDoc */\nfunction instrumentDOM() {\n  if (!('document' in WINDOW)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  WINDOW.document.addEventListener('click', globalDOMEventHandler, false);\n  WINDOW.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (WINDOW )[target] && (WINDOW )[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (\n\n        type,\n        listener,\n        options,\n      ) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this ;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount++;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener) {\n        return function (\n\n          type,\n          listener,\n          options,\n        ) {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const el = this ;\n              const handlers = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount--;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler = null;\n/** JSDoc */\nfunction instrumentError() {\n  _oldOnErrorHandler = WINDOW.onerror;\n\n  WINDOW.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = WINDOW.onunhandledrejection;\n\n  WINDOW.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n\nexport { addInstrumentationHandler };\n//# sourceMappingURL=instrument.js.map\n","import { logger } from './logger.js';\nimport { getGlobalObject } from './worldwide.js';\n\n// eslint-disable-next-line deprecation/deprecation\nconst WINDOW = getGlobalObject();\n\n/**\n * Tells whether current environment supports ErrorEvent objects\n * {@link supportsErrorEvent}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsErrorEvent() {\n  try {\n    new ErrorEvent('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMError objects\n * {@link supportsDOMError}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsDOMError() {\n  try {\n    // Chrome: VM89:1 Uncaught TypeError: Failed to construct 'DOMError':\n    // 1 argument required, but only 0 present.\n    // @ts-ignore It really needs 1 argument, not 0.\n    new DOMError('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports DOMException objects\n * {@link supportsDOMException}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsDOMException() {\n  try {\n    new DOMException('');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports Fetch API\n * {@link supportsFetch}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsFetch() {\n  if (!('fetch' in WINDOW)) {\n    return false;\n  }\n\n  try {\n    new Headers();\n    new Request('http://www.example.com');\n    new Response();\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * isNativeFetch checks if the given function is a native implementation of fetch()\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isNativeFetch(func) {\n  return func && /^function fetch\\(\\)\\s+\\{\\s+\\[native code\\]\\s+\\}$/.test(func.toString());\n}\n\n/**\n * Tells whether current environment supports Fetch API natively\n * {@link supportsNativeFetch}.\n *\n * @returns true if `window.fetch` is natively implemented, false otherwise\n */\nfunction supportsNativeFetch() {\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  // Fast path to avoid DOM I/O\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  if (isNativeFetch(WINDOW.fetch)) {\n    return true;\n  }\n\n  // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)\n  // so create a \"pure\" iframe to see if that has native fetch\n  let result = false;\n  const doc = WINDOW.document;\n  // eslint-disable-next-line deprecation/deprecation\n  if (doc && typeof (doc.createElement ) === 'function') {\n    try {\n      const sandbox = doc.createElement('iframe');\n      sandbox.hidden = true;\n      doc.head.appendChild(sandbox);\n      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        result = isNativeFetch(sandbox.contentWindow.fetch);\n      }\n      doc.head.removeChild(sandbox);\n    } catch (err) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) &&\n        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Tells whether current environment supports ReportingObserver API\n * {@link supportsReportingObserver}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsReportingObserver() {\n  return 'ReportingObserver' in WINDOW;\n}\n\n/**\n * Tells whether current environment supports Referrer Policy API\n * {@link supportsReferrerPolicy}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsReferrerPolicy() {\n  // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default'\n  // (see https://caniuse.com/#feat=referrer-policy),\n  // it doesn't. And it throws an exception instead of ignoring this parameter...\n  // REF: https://github.com/getsentry/raven-js/issues/1233\n\n  if (!supportsFetch()) {\n    return false;\n  }\n\n  try {\n    new Request('_', {\n      referrerPolicy: 'origin' ,\n    });\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Tells whether current environment supports History API\n * {@link supportsHistory}.\n *\n * @returns Answer to the given question.\n */\nfunction supportsHistory() {\n  // NOTE: in Chrome App environment, touching history.pushState, *even inside\n  //       a try/catch block*, will cause Chrome to output an error to console.error\n  // borrowed from: https://github.com/angular/angular.js/pull/13945/files\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const chrome = (WINDOW ).chrome;\n  const isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  const hasHistoryApi = 'history' in WINDOW && !!WINDOW.history.pushState && !!WINDOW.history.replaceState;\n\n  return !isChromePackagedApp && hasHistoryApi;\n}\n\nexport { isNativeFetch, supportsDOMError, supportsDOMException, supportsErrorEvent, supportsFetch, supportsHistory, supportsNativeFetch, supportsReferrerPolicy, supportsReportingObserver };\n//# sourceMappingURL=supports.js.map\n","module.exports = require('./dist/shared/lib/head')\n"],"names":["originalFunctionToString","cachedFetchImpl","SDK_VERSION","DEFAULT_IGNORE_ERRORS","InboundFilters","__initStatic","id","__init","name","constructor","_options","prototype","call","setupOnce","addGlobalEventProcessor","getCurrentHub","eventProcess","hub","self","getIntegration","ignoreErrors","client","getClient","clientOptions","getOptions","options","_mergeOptions","internalOptions","allowUrls","denyUrls","ignoreInternal","undefined","_shouldDropEvent","_isSentryError","event","exception","values","type","e","length","_getPossibleEventMessages","message","value","oO","some","string","U0","_isDeniedUrl","url","_getEventFilterUrl","_isAllowedUrl","frames","stacktrace","_getLastValidUrl","i","frame","filename","FunctionToString","Function","toString","args","context","object","HK","apply","installedIntegrations","createStackParser","parsers","sortedParsers","sort","a","b","map","p","stack","skipFirst","line","split","slice","cleanedLine","replace","parser","push","stripSentryFramesAndReverse","localStack","firstFrameFunction","function","lastFrameFunction","indexOf","reverse","defaultFunctionName","getFunctionName","fn","SentryError","Error","logLevel","Object","setPrototypeOf","DSN_REGEX","dsn_dsnToString","dsn","withPassword","host","path","pass","port","projectId","protocol","publicKey","dsnFromComponents","components","normalize","input","depth","maxProperties","visit","key","memo","memoBuilder","hasWeakSet","WeakSet","inner","obj","has","add","delete","splice","memoize","unmemoize","includes","is","i2","stringified","stringifyValue","_events","__webpack_require__","g","window","document","Cy","String","getPrototypeOf","err","startsWith","valueWithToJSON","toJSON","jsonValue","normalized","Array","isArray","numAdded","visitable","Sh","visitKey","hasOwnProperty","visitValue","ERROR","createEnvelope","headers","items","forEachEnvelopeItem","envelope","callback","envelopeItems","forEach","envelopeItemType","envelopeItem","encodeUTF8","textEncoder","utf8","TextEncoder","encode","serializeEnvelope","envHeaders","parts","JSON","stringify","append","next","item","itemHeaders","payload","Uint8Array","stringifiedPayload","concatBuffers","buffers","totalLength","reduce","acc","buf","merged","offset","buffer","set","ITEM_TYPE_TO_DATA_CATEGORY_MAP","session","sessions","attachment","transaction","client_report","user_report","getEnvelopeEndpointWithUrlEncodedAuth","tunnelOrOptions","tunnel","sdkInfo","_metadata","sdk","getBaseApiEndpoint","_j","sentry_key","sentry_version","sentry_client","version","getSdkMetadataForEnvelopeHeader","metadata","BaseClient","_integrations","__init2","_integrationsInitialized","__init3","_numProcessing","__init4","_outcomes","_dsn","dsn_makeDsn","from","dsnFromString","str","match","exec","lastPath","join","pop","projectMatch","_transport","transport","recordDroppedEvent","bind","transportOptions","captureException","hint","scope","misc","YO","eventId","event_id","_process","eventFromException","then","_captureEvent","result","captureMessage","level","promisedEvent","pt","eventFromMessage","captureEvent","originalException","captureSession","_isEnabled","release","sendSession","esm_session","CT","init","getDsn","getTransport","flush","timeout","_isClientDoneProcessing","clientFinished","transportFlushed","syncpromise","WD","close","enabled","setupIntegrations","integrations","integrationIndex","integration","esm_scope","c","esm_hub","Gd","getIntegrationById","integrationId","_oO","sendEvent","env","createEventEnvelope","eventType","packages","envelopeHeaders","createEventEnvelopeHeaders","dynamicSamplingContext","sdkProcessingMetadata","sent_at","Date","toISOString","trace","Jr","eventItem","attachments","addItemToEnvelope","newItem","createAttachmentEnvelopeItem","data","content_type","contentType","attachment_type","attachmentType","_sendEnvelope","createSessionEnvelope","reason","category","_event","sendClientReports","_updateSessionFromEvent","crashed","errored","exceptions","ex","mechanism","handled","sessionNonTerminal","status","shouldUpdateAndSend","errors","Number","cW","resolve","ticked","interval","setInterval","clearInterval","_prepareEvent","normalizeDepth","normalizeMaxBreadth","prepared","DM","timestamp","time","yW","_applyClientOptions","_applyIntegrationsMetadata","finalScope","captureContext","s","clone","update","getAttachments","applyToEvent","evt","_normalizeEvent","maxBreadth","breadcrumbs","user","contexts","extra","spans","span","environment","dist","maxValueLength","$G","request","integrationsArray","keys","_processEvent","finalEvent","sampleRate","$2","isTransaction","beforeSendProcessorName","beforeSendProcessor","Math","random","isInternalException","__sentry__","beforeSendResult","_validateBeforeSendResult","invalidValueError","J8","PO","processedEvent","getSession","transactionInfo","transaction_info","source","changes","propagations","promise","send","_clearOutcomes","outcomes","quantity","exceptionFromError","stackParser","parseStackFrames","extractMessage","error","eventFromError","popSize","getPopSize","framesToPop","reactMinifiedRegexp","test","eventFromUnknownInput","syntheticException","attachStacktrace","isUnhandledRejection","VW","errorEvent","TX","fm","domException","eventFromString","Db","tags","code","VZ","cO","eventFromPlainObject","zf","__serialized__","normalizeToSize","maxSize","encodeURI","EG","synthetic","helpers_WINDOW","worldwide","n2","ignoreOnError","wrap","before","wrapper","__sentry_wrapped__","sentryWrapped","arguments","wrappedArguments","arg","setTimeout","esm_exports","$e","addEventProcessor","Tb","property","$Q","xp","descriptor","getOwnPropertyDescriptor","configurable","defineProperty","get","validSeverityLevels","parseUrl","query","fragment","relative","BREADCRUMB_INTEGRATION_ID","Breadcrumbs","console","dom","fetch","history","sentry","xhr","instrument","o","_consoleBreadcrumb","handlerData","target","keyAttrs","serializeAttribute","maxStringLength","browser","Rt","addBreadcrumb","global","_xhrBreadcrumb","_fetchBreadcrumb","_historyBreadcrumb","addSentryBreadcrumb","jH","breadcrumb","logger","nK","endTimestamp","__sentry_own_request__","method","status_code","body","__sentry_xhr__","fetchData","response","to","parsedLoc","location","href","parsedFrom","parsedTo","BrowserClient","addEventListener","visibilityState","_flushOutcomes","breadcrumbIntegration","buildPolyfills_optionalChain","x","_","_2","platform","createClientReportEnvelope","discarded_events","clientReportItem","isRealNavigator","navigator","hasSendBeacon","sendBeacon","createFrame","func","lineno","colno","in_app","chromeRegex","chromeEvalRegex","chromeStackLineParser","isEval","subMatch","extractSafariExtensionDetails","geckoREgex","geckoEvalRegex","geckoStackLineParser","winjsRegex","winjsStackLineParser","defaultStackParser","isSafariExtension","isSafariWebExtension","DEFAULT_EVENT_TARGET","TryCatch","XMLHttpRequest","eventTarget","requestAnimationFrame","hl","_wrapTimeFunction","_wrapRAF","_wrapXHR","eventTargetOption","_wrapEventTarget","original","originalCallback","handler","originalSend","xmlHttpRequestProps","prop","wrapOptions","originalFunction","proto","globalObject","eventName","handleEvent","originalRemoveEventListener","originalEventHandler","wrappedEventHandler","GlobalHandlers","_installFunc","onerror","_installGlobalOnErrorHandler","onunhandledrejection","_installGlobalOnUnhandledRejectionHandler","stackTraceLimit","installFunc","getHubAndOptions","msg","column","shouldIgnoreOnError","HD","_eventFromIncompleteOnError","groups","_enhanceEventWithInitialFrame","addMechanismAndCapture","detail","ev","ev0","ev0s","ev0sf","isNaN","parseInt","l4","LinkedErrors","_key","_limit","limit","_handler","V9","linkedErrors","_walkErrorTree","Dedupe","eventProcessor","currentEvent","previousEvent","_previousEvent","_isSameMessageEvent","currentMessage","previousMessage","_isSameFingerprint","_isSameStacktrace","_isSameExceptionEvent","previousException","_getExceptionFromEvent","currentException","currentFrames","_getFramesFromEvent","previousFrames","frameA","frameB","currentFingerprint","fingerprint","previousFingerprint","HttpContext","referrer","userAgent","Referer","createTransport","makeRequest","makePromiseBuffer","remove","task","$","taskProducer","drain","reject","counter","capturedSetTimeout","clearTimeout","bufferSize","rateLimits","filteredEnvelopeItems","envelopeItemDataCategory","isRateLimited","limits","now","disabledUntil","all","getEventForEnvelopeItem","filteredEnvelope","recordEnvelopeLoss","statusCode","updateRateLimits","updatedRateLimits","rateLimitHeader","retryAfterHeader","trim","retryAfter","categories","headerDelay","delay","parseRetryAfterHeader","header","headerDate","parse","makeFetchTransport","nativeFetch","getNativeFetchImplementation","supports","Du","fetchImpl","createElement","sandbox","hidden","head","appendChild","contentWindow","removeChild","requestOptions","referrerPolicy","keepalive","fetchOptions","makeXHRTransport","onreadystatechange","readyState","getResponseHeader","open","setRequestHeader","defaultIntegrations","startSessionOnHub","startSession","ignoreDuration","sdk_init","__SENTRY_RELEASE__","SENTRY_RELEASE","autoSessionTracking","getIntegrationsToSetup","userIntegrations","isDefaultInstance","lE","finalIntegrations","filterDuplicates","integrationsByName","currentInstance","existingInstance","debugIndex","findIndex","debugInstance","Ak","initAndBind","clientClass","debug","warn","getScope","initialScope","bindClient","startSessionTracking","startIdleTransaction","transactionContext","idleTimeout","finalTimeout","onScope","customSamplingContext","heartbeatInterval","samplingContext","rate","_idletransaction_js__WEBPACK_IMPORTED_MODULE_2__","io","parentSampled","_utils_js__WEBPACK_IMPORTED_MODULE_0__","zu","sampled","setMetadata","tracesSampler","tracesSampleRate","_sentry_utils__WEBPACK_IMPORTED_MODULE_1__","initSpanRecorder","_experiments","maxSpans","SpanRecorder","maxlen","_maxlen","spanRecorder","Span","traceId","spanId","substring","startTimestamp","_I","__init5","__init6","__init7","instrumenter","spanContext","parentSpanId","op","description","startChild","childSpan","setTag","setData","setStatus","setHttpStatus","httpStatus","spanStatus","spanStatusfromHttpCode","isSuccess","finish","toTraceparent","sampledString","toContext","updateWithContext","_nullishCoalesce","h","getTraceContext","parent_span_id","span_id","trace_id","start_timestamp","Transaction","_measurements","_contexts","_frozenDynamicSamplingContext","_hub","_name","spanMetadata","_trimEnd","trimEnd","incomingDynamicSamplingContext","newName","setName","ph","setContext","setMeasurement","unit","newMetadata","finishedSpans","filter","prev","current","getDynamicSamplingContext","hasMeasurements","measurements","public_key","maybeSampleRate","sample_rate","segment","user_segment","getUser","dsc","DEFAULT_IDLE_TIMEOUT","DEFAULT_FINAL_TIMEOUT","DEFAULT_HEARTBEAT_INTERVAL","IdleTransactionSpanRecorder","_pushActivity","_popActivity","transactionSpanId","IdleTransaction","activities","_heartbeatCounter","_finished","_beforeFinishCallbacks","_idleHub","_idleTimeout","_finalTimeout","_heartbeatInterval","_onScope","clearActiveTransaction","configureScope","setSpan","_startIdleTimeout","keepSpan","registerBeforeFinishCallback","_pingHeartbeat","_cancelIdleTimeout","_idleTimeoutID","_beat","heartbeatString","_prevHeartbeatString","getTransaction","_lcpEntry","_clsEntry","TRACEPARENT_REGEXP","BAGGAGE_HEADER_NAME","SENTRY_BAGGAGE_KEY_PREFIX","SENTRY_BAGGAGE_KEY_PREFIX_REGEX","dynamicSamplingContextToSentryBaggageHeader","sentryPrefixedDSC","entries","dscKey","dscValue","objectToBaggageHeader","baggageHeader","objectKey","objectValue","currentIndex","baggageEntry","encodeURIComponent","newBaggageHeader","baggageHeaderToObject","keyOrValue","decodeURIComponent","WINDOW","bindReporter","metric","reportAllChanges","prevValue","delta","forceReport","generateUniqueID","floor","getNavigationEntryFromPerformanceTiming","timing","performance","navigation","navigationEntry","entryType","startTime","max","navigationStart","getNavigationEntry","__WEB_VITALS_POLYFILL__","getEntriesByType","getActivationStart","navEntry","activationStart","initMetric","navigationType","prerendering","rating","observe","opts","PerformanceObserver","supportedEntryTypes","po","list","getEntries","assign","buffered","onHidden","cb","once","onHiddenOrPageHide","removeEventListener","onCLS","onReport","report","sessionValue","sessionEntries","handleEntries","entry","hadRecentInput","firstSessionEntry","lastSessionEntry","takeRecords","firstHiddenTime","initHiddenTime","Infinity","trackChanges","timeStamp","getVisibilityWatcher","onFID","visibilityWatcher","handleEntry","processingStart","disconnect","reportedMetricIDs","onLCP","lastEntry","stopListening","capture","isMeasurementValue","isFinite","_startChild","ctx","getBrowserPerformanceAPI","_performanceCursor","_addPerformanceNavigationTiming","timeOrigin","eventEnd","end","start","utils","XL","DEFAULT_TRACE_PROPAGATION_TARGETS","defaultRequestInstrumentationOptions","traceFetch","traceXHR","tracingOrigins","tracePropagationTargets","DEFAULT_BROWSER_TRACING_OPTIONS","idletransaction","nT","mg","hd","markBackgroundTransactions","routingInstrumentation","customStartTransaction","startTransactionOnPageLoad","startTransactionOnLocationChange","activeTransaction","startingUrl","pathname","enableLongTask","BrowserTracing","_metricOptions","startTrackingWebVitals","Z1","mark","_reportAllChanges","_optionalChain","_3","_4","x1","duration","_getCurrentHub","instrumentRouting","shouldCreateSpanForRequest","_createRouteTransaction","instrumentOutgoingRequests","shouldCreateSpan","shouldAttachHeadersWithTargets","fetchCallback","shouldAttachHeaders","__span","addTracingHeadersToFetchRequest","sentryBaggageHeader","sentryTraceHeader","Request","baggage","Headers","newHeaders","existingBaggageHeader","newBaggageHeaders","xhrCallback","__sentry_xhr_span_id__","beforeNavigate","isPageloadTransaction","sentryTraceMetaTagValue","getMetaContent","baggageMetaTagValue","traceParentData","extractTraceparentData","traceparent","matches","baggageHeaderToDynamicSamplingContext","baggageObject","curr","currBaggageObject","nonPrefixedKey","expandedContext","modifiedContext","finalContext","idleTransaction","hubextensions","lb","addPerformanceEntries","responseStartTimestamp","requestStartTimestamp","performanceEntries","requestStart","responseEnd","responseStart","_addMeasureSpans","measureStartTimestamp","firstHidden","shouldRecord","resourceName","origin","_addResourceSpans","initiatorType","transferSize","encodedBodySize","decodedBodySize","_trackNavigator","connection","effectiveType","rtt","deviceMemory","hardwareConcurrency","oldValue","measurementTimestamp","normalizedValue","abs","fidMark","cls","measurementName","element","size","sources","index","node","metaName","metaTag","qT","getAttribute","hasTracingEnabled","maybeOptions","_sentry_core__WEBPACK_IMPORTED_MODULE_0__","getActiveTransaction","maybeHub","msToSec","lhs","rhsFn","ops","lastAccessLHS","lastHref","debounceTimerID","lastCapturedEvent","_worldwide_js__WEBPACK_IMPORTED_MODULE_0__","Rf","handlers","instrumented","addInstrumentationHandler","_logger_js__WEBPACK_IMPORTED_MODULE_1__","RU","_object_js__WEBPACK_IMPORTED_MODULE_2__","originalConsoleMethod","triggerHandlers","instrumentDOM","triggerDOMHandler","globalDOMEventHandler","makeDOMEventHandler","originalAddEventListener","listener","el","__sentry_instrumentation_handlers__","handlerForType","refCount","instrumentXHR","xhrproto","originalOpen","xhrInfo","_is_js__WEBPACK_IMPORTED_MODULE_4__","toUpperCase","onreadystatechangeHandler","readyStateArgs","_supports_js__WEBPACK_IMPORTED_MODULE_3__","t$","originalFetch","getFetchMethod","fetchArgs","getFetchUrl","instrumentHistory","Bf","oldOnPopState","onpopstate","historyReplacementFunction","originalHistoryFunction","_oldOnErrorHandler","_oldOnUnhandledRejectionHandler","globalListener","shouldSkipDOMEvent","tagName","isContentEditable","shouldShortcircuitPreviousDebounce","previous","supportsFetch","Response","isNativeFetch","supportsNativeFetch","doc","supportsHistory","chrome","isChromePackagedApp","app","runtime","hasHistoryApi","pushState","replaceState","module","exports"],"sourceRoot":""}