{"version":3,"file":"static/chunks/422.91966490399a8674.js","mappings":"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","sources":["webpack://_N_E/./node_modules/viem/_esm/errors/ccip.js","webpack://_N_E/./node_modules/viem/_esm/utils/address/isAddressEqual.js","webpack://_N_E/./node_modules/viem/_esm/utils/ccip.js","webpack://_N_E/<anon>"],"sourcesContent":["import { stringify } from '../utils/stringify.js';\nimport { BaseError } from './base.js';\nimport { getUrl } from './utils.js';\nexport class OffchainLookupError extends BaseError {\n    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {\n        super(cause.shortMessage ||\n            'An error occurred while fetching for an offchain result.', {\n            cause,\n            metaMessages: [\n                ...(cause.metaMessages || []),\n                cause.metaMessages?.length ? '' : [],\n                'Offchain Gateway Call:',\n                urls && [\n                    '  Gateway URL(s):',\n                    ...urls.map((url) => `    ${getUrl(url)}`),\n                ],\n                `  Sender: ${sender}`,\n                `  Data: ${data}`,\n                `  Callback selector: ${callbackSelector}`,\n                `  Extra data: ${extraData}`,\n            ].flat(),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupError'\n        });\n    }\n}\nexport class OffchainLookupResponseMalformedError extends BaseError {\n    constructor({ result, url }) {\n        super('Offchain gateway response is malformed. Response data must be a hex value.', {\n            metaMessages: [\n                `Gateway URL: ${getUrl(url)}`,\n                `Response: ${stringify(result)}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupResponseMalformedError'\n        });\n    }\n}\nexport class OffchainLookupSenderMismatchError extends BaseError {\n    constructor({ sender, to }) {\n        super('Reverted sender address does not match target contract address (`to`).', {\n            metaMessages: [\n                `Contract address: ${to}`,\n                `OffchainLookup sender address: ${sender}`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'OffchainLookupSenderMismatchError'\n        });\n    }\n}\n//# sourceMappingURL=ccip.js.map","import { InvalidAddressError, } from '../../errors/address.js';\nimport { isAddress } from './isAddress.js';\nexport function isAddressEqual(a, b) {\n    if (!isAddress(a))\n        throw new InvalidAddressError({ address: a });\n    if (!isAddress(b))\n        throw new InvalidAddressError({ address: b });\n    return a.toLowerCase() === b.toLowerCase();\n}\n//# sourceMappingURL=isAddressEqual.js.map","import { call } from '../actions/public/call.js';\nimport {} from '../errors/base.js';\nimport { OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError, } from '../errors/ccip.js';\nimport { HttpRequestError } from '../errors/request.js';\nimport { decodeErrorResult } from './abi/decodeErrorResult.js';\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js';\nimport { isAddressEqual } from './address/isAddressEqual.js';\nimport { concat } from './data/concat.js';\nimport { isHex } from './data/isHex.js';\nimport { stringify } from './stringify.js';\nexport const offchainLookupSignature = '0x556f1830';\nexport const offchainLookupAbiItem = {\n    name: 'OffchainLookup',\n    type: 'error',\n    inputs: [\n        {\n            name: 'sender',\n            type: 'address',\n        },\n        {\n            name: 'urls',\n            type: 'string[]',\n        },\n        {\n            name: 'callData',\n            type: 'bytes',\n        },\n        {\n            name: 'callbackFunction',\n            type: 'bytes4',\n        },\n        {\n            name: 'extraData',\n            type: 'bytes',\n        },\n    ],\n};\nexport async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {\n    const { args } = decodeErrorResult({\n        data,\n        abi: [offchainLookupAbiItem],\n    });\n    const [sender, urls, callData, callbackSelector, extraData] = args;\n    try {\n        if (!isAddressEqual(to, sender))\n            throw new OffchainLookupSenderMismatchError({ sender, to });\n        const result = await ccipFetch({ data: callData, sender, urls });\n        const { data: data_ } = await call(client, {\n            blockNumber,\n            blockTag,\n            data: concat([\n                callbackSelector,\n                encodeAbiParameters([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),\n            ]),\n            to,\n        });\n        return data_;\n    }\n    catch (err) {\n        throw new OffchainLookupError({\n            callbackSelector,\n            cause: err,\n            data,\n            extraData,\n            sender,\n            urls,\n        });\n    }\n}\nexport async function ccipFetch({ data, sender, urls, }) {\n    let error = new Error('An unknown error occurred.');\n    for (let i = 0; i < urls.length; i++) {\n        const url = urls[i];\n        const method = url.includes('{data}') ? 'GET' : 'POST';\n        const body = method === 'POST' ? { data, sender } : undefined;\n        try {\n            const response = await fetch(url.replace('{sender}', sender).replace('{data}', data), {\n                body: JSON.stringify(body),\n                method,\n            });\n            let result;\n            if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n                result = (await response.json()).data;\n            }\n            else {\n                result = (await response.text());\n            }\n            if (!response.ok) {\n                error = new HttpRequestError({\n                    body,\n                    details: result?.error\n                        ? stringify(result.error)\n                        : response.statusText,\n                    headers: response.headers,\n                    status: response.status,\n                    url,\n                });\n                continue;\n            }\n            if (!isHex(result)) {\n                error = new OffchainLookupResponseMalformedError({\n                    result,\n                    url,\n                });\n                continue;\n            }\n            return result;\n        }\n        catch (err) {\n            error = new HttpRequestError({\n                body,\n                details: err.message,\n                url,\n            });\n        }\n    }\n    throw error;\n}\n//# sourceMappingURL=ccip.js.map"],"names":["OffchainLookupError","base","G","constructor","callbackSelector","cause","data","extraData","sender","urls","shortMessage","metaMessages","length","map","utils","Gr","url","flat","Object","defineProperty","enumerable","configurable","writable","value","OffchainLookupResponseMalformedError","result","stringify","P","OffchainLookupSenderMismatchError","to","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","offchainLookup","client","blockNumber","blockTag","args","decodeErrorResult","p","abi","callData","isAddressEqual","a","b","isAddress","U","address","toLowerCase","ccipFetch","data_","call","R","concat","zo","encodeAbiParameters","E","err","error","i","method","includes","body","undefined","response","fetch","replace","JSON","headers","get","startsWith","json","text","ok","request","Gg","details","statusText","status","isHex","v","message"],"sourceRoot":""}